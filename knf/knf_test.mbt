
///|
test "Apply Expr Knf Transformation Test" {
  // Prelude Parts
  // set a, b, x, arr, point, max type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("a", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("b", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: false } },
      { name: "y", ty: { kind: Int, mutable: false } },
    ],
    methods: Map::new(),
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  typecheck_ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
  typecheck_ctx.type_env.set("max", {
    kind: Function([Int, Int], Int),
    mutable: false,
  })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("max", Function([Int, Int], Int))
  let _ = knf_ctx.add_new_name("a", Int)
  let _ = knf_ctx.add_new_name("b", Int)
  let _ = knf_ctx.add_new_name("x", Int)
  let _ = knf_ctx.add_new_name("arr", Array(Int))
  let _ = knf_ctx.add_new_name("point", Struct("Point"))

  // Test Parts
  let code =
    #|arr[3]
    #|arr[x]
    #|point.x
    #|max(a + b, a - b)
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `arr[3]`.
  let (e, tok_view) = @parser.parse_apply_expr(tokens)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [s1] &&
    s1 is Let(n1, Int, Int(3)) &&
    knf_expr is ArrayAccess(arr_name, index_name) &&
    arr_name is { id: "arr", .. } &&
    index_name == n1,
  )
  // Parse and transform `arr[x]`.
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is ArrayAccess(arr_name, index_name) &&
    arr_name is { id: "arr", .. } &&
    index_name is { id: "x", .. },
  )
  // Parse and transform `point.x`.
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is FieldAccess(struct_name, field_name) &&
    struct_name is { id: "point", .. } &&
    field_name is "x",
  )
  // Parse and transform `max(a + b, a - b)`.
  let (e, _) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (stmts, knf_expr) = knf_ctx.apply_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Int, Binary(Add, l1, r1)) &&
    l1.id is "a" &&
    r1.id is "b" &&
    s2 is Let(n2, Int, Binary(Sub, l2, r2)) &&
    l2.id is "a" &&
    r2.id is "b" &&
    knf_expr is Call(callee_name, arg_names) &&
    callee_name.id is "max" &&
    arg_names == [n1, n2],
  )
}

///|
test "Assign Stmt Knf Transformation Test" {
  // Prelude Parts
  // set x, y type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [{ name: "x", ty: { kind: Int, mutable: true } }],
    methods: Map::new(),
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("y", { kind: Double, mutable: true })
  typecheck_ctx.type_env.set("mat", { kind: Array(Array(Int)), mutable: true })
  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
  let knf_ctx = Context::new()
  let _ = knf_ctx.add_new_name("x", Int)
  let _ = knf_ctx.add_new_name("y", Double)
  let _ = knf_ctx.add_new_name("arr", Array(Int))
  let _ = knf_ctx.add_new_name("point", Struct("Point"))
  let _ = knf_ctx.add_new_name("mat", Array(Array(Int)))

  // Test Parts
  let code =
    #|x = 10;
    #|y = 3.14;
    #|x += 5;
    #|y -= 1.0;
    #|mat[0][0] = 42;
    #|point.x = 100;
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)

  // Parse and transform `x = 10;`
  let (stmt, tok_view) = @parser.parse_assign_stmt(tokens)
  let stmt = typecheck_ctx.check_assign_stmt(stmt)
  let knf_stmts = knf_ctx.assign_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Assign(name, expr) &&
    name is { id: "x", .. } &&
    expr is Int(10),
  )

  // Parse and transform `y = 3.14;`
  let (stmt, tok_view) = @parser.parse_assign_stmt(tok_view)
  let stmt = typecheck_ctx.check_assign_stmt(stmt)
  let knf_stmts = knf_ctx.assign_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Assign(name, expr) &&
    name is { id: "y", .. } &&
    expr is Double(3.14),
  )

  // Parse and transform `x += 5;`
  let (stmt, tok_view) = @parser.parse_assign_stmt(tok_view)
  let stmt = typecheck_ctx.check_assign_stmt(stmt)
  let knf_stmts = knf_ctx.assign_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(5)) &&
    s2 is Let(_, Int, Binary(Add, _, _)) &&
    s3 is Assign(name, Ident(_)) &&
    name is { id: "x", .. },
  )

  // Parse and transform `y -= 1.0;`
  let (stmt, tok_view) = @parser.parse_assign_stmt(tok_view)
  let stmt = typecheck_ctx.check_assign_stmt(stmt)
  let knf_stmts = knf_ctx.assign_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Double, Double(1.0)) &&
    s2 is Let(_, Double, Binary(Sub, _, _)) &&
    s3 is Assign(name, Ident(_)) &&
    name is { id: "y", .. },
  )
  // Parse and transform `max[0][0] = 42;`
  let (stmt, tok_view) = @parser.parse_assign_stmt(tok_view)
  let stmt = typecheck_ctx.check_assign_stmt(stmt)
  let knf_stmts = knf_ctx.assign_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3, s4] &&
    s1 is Let(n1, Int, Int(0)) &&
    s2 is Let(n2, Array(Int), ArrayAccess(_, mat_idx_name)) &&
    s3 is Let(n3, Int, Int(0)) &&
    s4 is ArrayPut(array_name, idx_name, Int(42)) &&
    n1 == mat_idx_name &&
    array_name == n2 &&
    idx_name == n3,
  )
  // Parse and transform `point.x = 100;`
  let (stmt, _) = @parser.parse_assign_stmt(tok_view)
  let stmt = typecheck_ctx.check_assign_stmt(stmt)
  let knf_stmts = knf_ctx.assign_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2] &&
    s1 is Let(n1, Int, Int(100)) &&
    s2 is StructFieldSet(_, "x", value_name) &&
    n1 == value_name,
  )
}

///|
test "Atom Expr Knf Transformation Test" {
  // set a, b, x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("a", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("b", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("x", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: String, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Bool, mutable: false })
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: false } },
      { name: "y", ty: { kind: Int, mutable: false } },
    ],
    methods: Map::new(),
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Double)
  let _ = knf_ctx.add_new_name("y", String)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)
  let _ = knf_ctx.add_new_name("a", Int)
  let _ = knf_ctx.add_new_name("b", Int)

  // Code parse, typecheck, knf transform
  let code =
    #|(a + b)
    #|[1, 2, 3]
    #|(x, y, z)
    #|Array::make(5, 0)
    #|Point::{ x: 10, y: 20 }
  let tokens = @lexer.tokenize(code)
  // Parse and transform `(a + b)`.
  let (e, tok_view) = @parser.parse_atom_expr(tokens)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is Binary(Add, l, r) &&
    l is { id: "a", .. } &&
    r is { id: "b", .. },
  )
  // Parse and transform `[1, 2, 3]`.
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2, s3] &&
    s1 is Let(n1, Int, Int(1)) &&
    s2 is Let(n2, Int, Int(2)) &&
    s3 is Let(n3, Int, Int(3)) &&
    knf_expr is ArrayLiteral(_, [a1, a2, a3]) &&
    n1 == a1 &&
    n2 == a2 &&
    n3 == a3,
  )
  // Parse and transform `(x, y, z)`.
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [] &&
    knf_expr is TupleLiteral([t1, t2, t3]) &&
    t1 is { id: "x", .. } &&
    t2 is { id: "y", .. } &&
    t3 is { id: "z", .. },
  )
  // Parse and transform `Array::make(5, 0)`.
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Int, Int(5)) &&
    s2 is Let(n2, Int, Int(0)) &&
    knf_expr is ArrayMake(size_name, init_name) &&
    size_name == n1 &&
    init_name == n2,
  )
  // Parse and transform `Point::{ x: 10, y: 20 }`.
  let (e, _) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (stmts, knf_expr) = knf_ctx.atom_expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Int, Int(10)) &&
    s2 is Let(n2, Int, Int(20)) &&
    knf_expr is CreateStruct("Point", [("x", f1), ("y", f2)]) &&
    n1 == f1 &&
    n2 == f2,
  )
}

///|
test "Block Expr Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup type environment for testing
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })

  // For return statement
  typecheck_ctx.current_func_ret_ty = Some(Int)

  // Setup knf context
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  // Test Parts
  let code =
    #|{
    #|  let x: Int = 10;
    #|  let mut y: Double = 3.14;
    #|  let mut z : Int = 0;
    #|  z = 42;
    #|  print_int(z);
    #|  return z;
    #|}

  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  let (stmt, _) = @parser.parse_block_expr(tokens)
  let checked_block = typecheck_ctx.check_block_expr(stmt)
  let knf_block = knf_ctx.block_expr_to_knf(checked_block)
  assert_true(knf_block.stmts.length() is 6)

  // Test 1: Parse and transform `let x: Int = 10;`
  assert_true(
    knf_block.stmts[0] is Let(name1, Int, init_expr) &&
    name1 is { id: "x", .. } &&
    init_expr is Int(10),
  )

  // Test 2: Parse and transform `let mut y: Double = 3.14;`
  assert_true(
    knf_block.stmts[1] is LetMut(name2, Double, init_expr2) &&
    name2 is { id: "y", .. } &&
    init_expr2 is Double(3.14),
  )

  // Test 3: Parse and transform `let mut z : Int = 0;`
  assert_true(
    knf_block.stmts[2] is LetMut(name3, Int, init_expr3) &&
    name3 is { id: "z", .. } &&
    init_expr3 is Int(0),
  )

  // Test 4: Parse and transform `z = 42;`
  assert_true(
    knf_block.stmts[3] is Assign(name3, expr3) &&
    name3 is { id: "z", .. } &&
    expr3 is Int(42),
  )

  // Test 4: Parse and transform `print_int(z);` (ExprStmt)
  assert_true(
    knf_block.stmts[4] is ExprStmt(call_expr) &&
    call_expr is Call(func, args) &&
    func is { id: "print_int", .. } &&
    args is [arg] &&
    arg is { id: "z", .. },
  )

  // Test 5: Parse and transform `return z;` (ReturnStmt)
  assert_true(
    knf_block.stmts[5] is Return(return_expr) &&
    return_expr is Ident({ id: "z", .. }),
  )
}

///|
test "Expr Knf Transformation Test" {
  // Prelucde Parts
  // set a, b, arr, sum, point, mat, sqrt type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: false } },
      { name: "y", ty: { kind: Int, mutable: false } },
    ],
    methods: Map::new(),
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)
  typecheck_ctx.type_env.set("a", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("b", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("arr", { kind: Array(Int), mutable: false })
  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
  typecheck_ctx.type_env.set("sum", {
    kind: Function([Array(Int)], Int),
    mutable: false,
  })
  typecheck_ctx.type_env.set("max", {
    kind: Function([Double, Double], Double),
    mutable: false,
  })
  typecheck_ctx.type_env.set("min", {
    kind: Function([Double, Double], Double),
    mutable: false,
  })
  let knf_ctx = @knf.Context::new()
  knf_ctx.globals.set("max", Function([Double, Double], Double))
  knf_ctx.globals.set("min", Function([Double, Double], Double))
  knf_ctx.globals.set("sum", Function([Array(Int)], Int))
  let _ = knf_ctx.add_new_name("a", Double)
  let _ = knf_ctx.add_new_name("b", Double)
  let _ = knf_ctx.add_new_name("arr", Array(Int))

  // Test Parts
  let code =
    #|max(a, b) + min(a, b) ;
    #|sum(arr) / arr.length() ;
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `max(a, b) + min(a, b)`
  let (e, _) = @parser.parse_expr(tokens)
  let e = typecheck_ctx.check_expr(e)
  let (stmts, knf_expr) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Double, Call({ id: "max", .. }, [a1, a2])) &&
    s2 is Let(n2, Double, Call({ id: "min", .. }, [a3, a4])) &&
    a1 is { id: "a", .. } &&
    a2 is { id: "b", .. } &&
    a3 is { id: "a", .. } &&
    a4 is { id: "b", .. } &&
    knf_expr is Binary(Add, l, r) &&
    n1 == l &&
    n2 == r,
  )
}

///|
test "If Expr Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup type environment for testing
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("y", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })

  // Setup knf context
  let _ = knf_ctx.add_new_name("x", Int)
  let _ = knf_ctx.add_new_name("y", Int)
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  // Test 1: Simple if-else expression: if (y > 0) { x = 10; } else { x = 20; }
  let code1 =
    #|if (y > 0) {
    #|  x = 10;
    #|} else {
    #|  x = 20;
    #|}
  let tokens1 = @lexer.tokenize(code1)
  let (if_expr1, _) = @parser.parse_if_expr(tokens1)
  let checked_if_expr1 = typecheck_ctx.check_if_expr(if_expr1)
  let (stmts1, knf_if_expr1) = knf_ctx.if_expr_to_knf(checked_if_expr1)

  // Test 1: Check that condition generates a statement for the literal 0
  assert_true(stmts1.length() is 1)
  assert_true(
    stmts1[0] is Let(tmp_name, Int, Int(0)) && tmp_name is { id: "tmp", .. },
  )

  // Test 1: Check the if expression structure
  assert_true(
    knf_if_expr1 is If(cond, then_block, else_block) &&
    cond is Binary(GT, y_name, tmp_cond) &&
    y_name is { id: "y", .. } &&
    tmp_cond is { id: "tmp", .. } &&
    then_block.stmts.length() is 1 &&
    then_block.stmts[0] is Assign(x_name1, Int(10)) &&
    x_name1 is { id: "x", .. } &&
    else_block.stmts.length() is 1 &&
    else_block.stmts[0] is Assign(x_name2, Int(20)) &&
    x_name2 is { id: "x", .. },
  )

  // Test 2: If without else: if (x < 5) { print_int(x); }
  let code2 =
    #|if (x < 5) {
    #|  print_int(x);
    #|}
  let tokens2 = @lexer.tokenize(code2)
  let (if_expr2, _) = @parser.parse_if_expr(tokens2)
  let checked_if_expr2 = typecheck_ctx.check_if_expr(if_expr2)
  let (stmts2, knf_if_expr2) = knf_ctx.if_expr_to_knf(checked_if_expr2)

  // Test 2: Check that condition generates a statement for the literal 5
  assert_true(stmts2.length() is 1)
  assert_true(
    stmts2[0] is Let(tmp_name2, Int, Int(5)) &&
    tmp_name2 is { id: "tmp", slot: 1 },
  )

  // Test 2: Check the if expression structure (no else block)
  assert_true(
    knf_if_expr2 is If(cond2, then_block2, else_block2) &&
    cond2 is Binary(LT, x_name3, tmp_cond2) &&
    x_name3 is { id: "x", .. } &&
    tmp_cond2 is { id: "tmp", slot: 1 } &&
    then_block2.stmts.length() is 1 &&
    then_block2.stmts[0] is ExprStmt(Call(print_func, [x_arg])) &&
    print_func is { id: "print_int", .. } &&
    x_arg is { id: "x", .. } &&
    else_block2.stmts.is_empty(),
  )

  // Test 3: If-else if-else chain
  let code3 =
    #|if x > 10 {
    #|  y
    #|} else if x > 5 {
    #|  y + 1
    #|} else {
    #|  y + 2
    #|}
  let tokens3 = @lexer.tokenize(code3)
  let (if_expr3, _) = @parser.parse_if_expr(tokens3)
  let checked_if_expr3 = typecheck_ctx.check_if_expr(if_expr3)
  let (stmts3, knf_if_expr3) = knf_ctx.if_expr_to_knf(checked_if_expr3)

  // Test 3: Check that condition generates a statement for the literal 10
  assert_true(stmts3.length() is 2)
  assert_true(
    stmts3 is [s1, s2] &&
    s1 is Let(_, Int, Int(10)) &&
    s2 is Let(_, Int, Int(5)),
  )
  assert_true(
    knf_if_expr3 is If(cond3, then_block3, else_block3) &&
    cond3 is Binary(GT, _, _) &&
    then_block3.stmts is [_] &&
    else_block3.stmts is [ExprStmt(e1)] &&
    e1 is If(nested_cond, _, _) &&
    nested_cond is Binary(GT, _, _),
  )
}

///|
test "Let Mut Knf Transformation Test" {
  // Prelucde Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()
  // Test Parts
  let code =
    #|let mut x: Int = 10;
    #|let mut a = 42.0;
    #|let mut b = 33.0;
    #|let mut y: Double = a + b;
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `let mut x: Int = 10;`
  let (stmt, tok_view) = @parser.parse_let_mut_stmt(tokens)
  let stmt = typecheck_ctx.check_let_mut_stmt(stmt)
  let knf_stmts = knf_ctx.let_mut_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is LetMut(name1, Int, init_expr) &&
    name1 is { id: "x", .. } &&
    init_expr is Int(10),
  )
  // Parse and transform `let mut a = 42.0;`
  let (stmt1, tok_view) = @parser.parse_let_mut_stmt(tok_view)
  let stmt1 = typecheck_ctx.check_let_mut_stmt(stmt1)
  let knf_stmts1 = knf_ctx.let_mut_stmt_to_knf(stmt1)
  assert_true(
    knf_stmts1 is [s1] &&
    s1 is LetMut(name_a, Double, init_expr1) &&
    name_a is { id: "a", .. } &&
    init_expr1 is Double(42.0),
  )
  // Parse and transform `let mut b = 33.0;`
  let (stmt_b, tok_view) = @parser.parse_let_mut_stmt(tok_view)
  let stmt_b = typecheck_ctx.check_let_mut_stmt(stmt_b)
  let knf_stmts_b = knf_ctx.let_mut_stmt_to_knf(stmt_b)
  assert_true(
    knf_stmts_b is [s_b] &&
    s_b is LetMut(name_b, Double, init_expr_b) &&
    name_b is { id: "b", .. } &&
    init_expr_b is Double(33.0),
  )
  // Parse and transform `let mut y: Double = a + b;`
  let (stmt2, _) = @parser.parse_let_mut_stmt(tok_view)
  let stmt2 = typecheck_ctx.check_let_mut_stmt(stmt2)
  let knf_stmts2 = knf_ctx.let_mut_stmt_to_knf(stmt2)
  assert_true(
    knf_stmts2 is [s2] &&
    s2 is LetMut(name2, Double, init_expr2) &&
    name2 is { id: "y", .. } &&
    init_expr2 is Binary(Add, left, right) &&
    left is { id: "a", .. } &&
    right is { id: "b", .. },
  )
}

///|
test "Let Stmt Knf Transformation Test" {
  // Prelucde Parts
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })
  let knf_ctx = @knf.Context::new()
  knf_ctx.globals.set("print_int", Function([Int], Unit))
  // Test Parts
  let code =
    #|let x: Int = 10;
    #|let (a, b) = (42.0, 33.0);
    #|let y: Double = a + b;
    #|let _ = print_int(x);
  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)
  // Parse and transform `let x: Int = 10;`
  let (stmt, tok_view) = @parser.parse_let_stmt(tokens)
  let stmt = typecheck_ctx.check_let_stmt(stmt)
  let knf_stmts = knf_ctx.let_stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Let(name1, Int, init_expr) &&
    name1 is { id: "x", .. } &&
    init_expr is Int(10),
  )
  // Parse and transform `let (a, b) = (42.0, 33.0);`
  // It Should be transformed into 4 let statements in knf
  // 1. let tmp1: Double = 42.0;
  // 2. let tmp2: Double = 33.0;
  // 3. let a = tmp1;
  // 4. let b = tmp2;
  // Not: let tmp3 = (tmp1, tmp2); then let a = tmp1.0; let b = tmp1.1
  // Although it's correct, it's not efficient way, be cause we need
  // to create a tuple object in memory.
  //
  // Ask: Does `let a = 42.0; let b = 33.0;` better?
  // Well, you can try it. But it may not easy in knf transformation phase.
  let (stmt1, tok_view) = @parser.parse_let_stmt(tok_view)
  let stmt1 = typecheck_ctx.check_let_stmt(stmt1)
  let knf_stmts1 = knf_ctx.let_stmt_to_knf(stmt1)
  assert_true(
    knf_stmts1 is [s1, s2, s3, s4] &&
    s1 is Let(n1, Double, Double(42.0)) &&
    s2 is Let(n2, Double, Double(33.0)) &&
    s3 is Let(a, _, Ident(n1_)) &&
    s4 is Let(b, _, Ident(n2_)) &&
    n1 == n1_ &&
    n2 == n2_ &&
    a is { id: "a", .. } &&
    b is { id: "b", .. },
  )
  // Parse and transform `let y: Double = a + b;`
  let (stmt2, tok_view) = @parser.parse_let_stmt(tok_view)
  let stmt2 = typecheck_ctx.check_let_stmt(stmt2)
  let knf_stmts2 = knf_ctx.let_stmt_to_knf(stmt2)
  assert_true(
    knf_stmts2 is [s2] &&
    s2 is Let(name2, Double, init_expr2) &&
    name2 is { id: "y", .. } &&
    init_expr2 is Binary(Add, left, right) &&
    left is { id: "a", .. } &&
    right is { id: "b", .. },
  )
  // Parse and transform `let _ = print_int(y);`
  let (stmt3, _) = @parser.parse_let_stmt(tok_view)
  let stmt3 = typecheck_ctx.check_let_stmt(stmt3)
  let knf_stmts3 = knf_ctx.let_stmt_to_knf(stmt3)
  assert_true(
    knf_stmts3 is [s3] &&
    s3 is Let(_, Unit, call_expr) &&
    call_expr is Call(func, args) &&
    func is { id: "print_int", .. } &&
    args is [arg] &&
    arg is { id: "x", .. },
  )
}

///|
test "Local Function Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup builtin functions
  typecheck_ctx.func_types.set("print_int", Function([Int], Unit))
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })
  // Typecheck ctx need to know about 'foo' ahead of time.
  // So that we can call `check_top_function` directly.
  typecheck_ctx.func_types.set("foo", Function([], Unit))
  knf_ctx.globals.set("print_int", Function([Int], Unit))
  let code =
    #|fn foo() -> Unit {
    #|  let x = 1;
    #|  fn bar() -> Unit {
    #|    fn baz() -> Unit {
    #|      print_int(x);
    #|    }
    #|    baz();
    #|  }
    #|  bar();
    #|}
  let tokens = @lexer.tokenize(code)
  let (top_func, _) = @parser.parse_top_function(tokens)
  let typechecked_func = typecheck_ctx.check_top_function(top_func)
  let knf_func = knf_ctx.top_function_to_knf(typechecked_func)
  assert_true(knf_func.body.stmts.length() is 3)
  // Second statement is local function 'bar'
  assert_true(
    knf_func.body.stmts[1] is ClosureDef(closure) && // closure 'bar'
    closure.captured_vars.length() is 1 && // bar captures 'x'
    closure.body.stmts is [s1, _] &&
    s1 is ClosureDef(inner_closure) && // inner closure 'baz'
    inner_closure.captured_vars.length() is 1, // baz captures 'x' from bar
  )
}

///|
test "Top Function Knf Transformation Test" {
  let code =
    #|extern "C" fn print_int(n: Int) = "print_int";
    #|let a = 3;
    #|let b = 4;
    #|fn fold(arr: Array[Int], f: (Int, Int) -> Int, initv: Int) -> Int { 
    #|  let mut result = initv;
    #|  let mut i = 0; 
    #|  while i < arr.length() {
    #|    result = f(result, arr[i]);
    #|  }
    #|  result
    #|}
    #|
    #|fn main {
    #|  fn max(a, b) { if a > b { a } else { b } }
    #|  fn min(a, b) { if a < b { a } else { b } }
    #|  let numbers = [a, 1, b, 1, 5, 9, 2, 6, 5];
    #|  let maximum = fold(numbers, max, -1000);
    #|  let minimum = fold(numbers, min, 1000);
    #|  let max_min_diff = maximum - minimum;
    #|  print_int(max_min_diff);
    #|}
  let tokens = @lexer.tokenize(code)
  let program = @parser.parse(tokens)
  let program = @typecheck.typecheck(program)
  let knf = knf_transform(program)
  assert_true(knf.top_lets.contains("a"))
  assert_true(knf.top_lets.contains("b"))
  assert_true(knf.functions.contains("fold"))
  assert_true(knf.functions.contains("main"))
  // if you call println(knf), you should see
  // the knf program like follows: 
  // ```
  // let a : Int = 3;
  // let b : Int = 4;
  // fn fold(arr: Array[Int], f: (Int, Int) -> Int, initv: Int) -> Int {
  //   let mut result : Int = initv;
  //   let mut i : Int = 0;
  //   while {let tmp : () -> Int = arr.length; let tmp$1 : Int = tmp(); i < tmp$1; } {
  //     let tmp$2 : Int = arr[i];
  //     result = f(result, tmp$2);
  //   }
  //   result;
  // }
  // fn main {
  //   fn max(a$1 : Int, b$1 : Int) -> Int {
  //     if a$1 > b$1 {
  //       a$1;
  //     } else {
  //       b$1;
  //     };
  //   }
  //   fn min(a$1 : Int, b$1 : Int) -> Int {
  //     if a$1 < b$1 {
  //       a$1;
  //     } else {
  //       b$1;
  //     };
  //   }
  //   let tmp : Int = 1;
  //   let tmp$1 : Int = 1;
  //   let tmp$2 : Int = 5;
  //   let tmp$3 : Int = 9;
  //   let tmp$4 : Int = 2;
  //   let tmp$5 : Int = 6;
  //   let tmp$6 : Int = 5;
  //   let numbers : Array[Int] = [a, tmp, b, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6];
  //   let tmp$7 : Int = 1000;
  //   let tmp$8 : Int = -tmp$7;
  //   let maximum : Int = fold(numbers, max, tmp$8);
  //   let tmp$9 : Int = 1000;
  //   let minimum : Int = fold(numbers, min, tmp$9);
  //   let max_min_diff : Int = maximum - minimum;
  //   print_int(max_min_diff);
  // }
  // ```
}

///|
test "Simple Apply Expr Knf Transformation Test" {
  // set x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Bool, mutable: false })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Int)
  let _ = knf_ctx.add_new_name("y", Double)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)

  // Code parse, typecheck, knf transform
  let code =
    #|42 3.14 true "hello"
    #|x y z
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = @parser.parse_apply_expr(tokens)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Int(42))
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Double(3.14))
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Bool(true))
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is String("hello"))
  // find Global Ident `x`
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Ident({ id: "x", slot: 0 }))
  // find Parent Ident `y`
  let (e, tok_view) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Ident({ id: "y", slot: 0 }))
  // find Local Ident `z`
  let (e, _) = @parser.parse_apply_expr(tok_view)
  let e = typecheck_ctx.check_apply_expr(e)
  let (_, e) = knf_ctx.apply_expr_to_knf(e)
  assert_true(e is Ident({ id: "z", slot: 0 }))
}

///|
test "Simple Atom Expr Knf Transformation Test" {
  // set x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: Double, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Bool, mutable: false })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Int)
  let _ = knf_ctx.add_new_name("y", Double)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)

  // Code parse, typecheck, knf transform
  let code =
    #|42 3.14 true "hello"
    #|x y z
  // Parse
  let tokens = @lexer.tokenize(code)
  let (e, tok_view) = @parser.parse_atom_expr(tokens)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Int(42))
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Double(3.14))
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Bool(true))
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is String("hello"))
  // find Global Ident `x`
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Ident({ id: "x", slot: 0 }))
  // find Parent Ident `y`
  let (e, tok_view) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Ident({ id: "y", slot: 0 }))
  // find Local Ident `z`
  let (e, _) = @parser.parse_atom_expr(tok_view)
  let e = typecheck_ctx.check_atom_expr(e)
  let (_, e) = knf_ctx.atom_expr_to_knf(e)
  assert_true(e is Ident({ id: "z", slot: 0 }))
}

///|
test "Simple Expr Knf Transformation Test" {
  // set x, y, z type in typecheck and knf context
  let typecheck_ctx = @typecheck.Context::new()
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("y", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("z", { kind: Int, mutable: false })
  typecheck_ctx.type_env.set("w", { kind: Bool, mutable: false })
  let knf_ctx = Context::new()
  knf_ctx.globals.set("x", Int)
  let _ = knf_ctx.add_new_name("y", Int)
  let _ = knf_ctx.add_new_name("w", Int)
  knf_ctx.enter_scope()
  let _ = knf_ctx.add_new_name("z", Bool)

  // Code parse, typecheck, knf transform
  let code =
    #|42;
    #|-33;
    #|!w;
    #|x + y;
    #|2.0 * 3.14;
    #|x + y * z ;
  let tokens = @lexer.tokenize(code)
  // Parse and transform `42` 
  let (e, tok_view) = @parser.parse_expr(tokens)
  let e = typecheck_ctx.check_expr(e)
  let (_, e) = knf_ctx.expr_to_knf(e)
  assert_true(e is Int(42))
  // Parse and transform `-33`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s] && s is Let(n1, Int, Int(33)) && e is Neg(n2) && n1 == n2,
  )
  // Parse and transform `!z`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s] &&
    s is Let(n1, Bool, Ident(i)) &&
    i is { id: "w", .. } &&
    e is Not(n2) &&
    n1 == n2,
  )
  // Parse and transform `x + 10`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [] &&
    e is Binary(Add, n1, n2) &&
    n1 is { id: "x", .. } &&
    n2 is { id: "y", .. },
  )
  // Parse and transform `2.0 * 3.14`
  let (e, tok_view) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s1, s2] &&
    s1 is Let(n1, Double, Double(2.0)) &&
    s2 is Let(n2, Double, Double(3.14)) &&
    e is Binary(Mul, n3, n4) &&
    n1 == n3 &&
    n2 == n4,
  )
  // Parse and transform `x + y * z`
  let (e, _) = @parser.parse_expr(tok_view[1:])
  let e = typecheck_ctx.check_expr(e)
  let (stmts, e) = knf_ctx.expr_to_knf(e)
  assert_true(
    stmts is [s] &&
    s is Let(n1, Int, Binary(Mul, n2, n3)) &&
    e is Binary(Add, n4, n5) &&
    n1 is { id: "tmp", .. } &&
    n2 is { id: "y", .. } &&
    n3 is { id: "z", .. } &&
    n4 is { id: "x", .. } &&
    n5 == n1,
  )
}

///|
//test "Stmt Knf Transformation Test - 2" {
//  // Prelude Parts
//  let typecheck_ctx = @typecheck.Context::new()
//  let knf_ctx = @knf.Context::new()
//
//  // Setup struct definition for testing
//  let point_struct_def : @typecheck.StructDef = {
//    name: "Point",
//    fields: [
//      { name: "x", ty: { kind: Int, mutable: true } },
//      { name: "y", ty: { kind: Int, mutable: true } },
//    ],
//  }
//  typecheck_ctx.struct_defs.set("Point", point_struct_def)
//
//  // Setup type environment
//  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
//  typecheck_ctx.type_env.set("arr", { kind: Array(Int), mutable: true })
//  typecheck_ctx.type_env.set("point", { kind: Struct("Point"), mutable: false })
//
//  // Set function context for return statement
//  typecheck_ctx.current_func_ret_ty = Some(Unit)
//
//  // Setup knf context
//  let _ = knf_ctx.add_new_name("x", Int)
//  let _ = knf_ctx.add_new_name("arr", Array(Int))
//  let _ = knf_ctx.add_new_name("point", Struct("Point"))
//
//  // Test Parts
//  let code =
//    #|let (a, b) = (10, 20);
//    #|x += 5;
//    #|arr[0] = 42;
//    #|point.x = 100;
//    #|return;
//
//  // Code parse, typecheck, knf transform
//  let tokens = @lexer.tokenize(code)
//
//  // Test 1: Parse and transform `let (a, b) = (10, 20);` (tuple pattern)
//  let (stmt, tok_view) = @parser.parse_stmt(tokens)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2, s3, s4] &&
//    s1 is Let(n1, Int, Int(10)) &&
//    s2 is Let(n2, Int, Int(20)) &&
//    s3 is Let(a, _, Ident(n1_)) &&
//    s4 is Let(b, _, Ident(n2_)) &&
//    n1 == n1_ &&
//    n2 == n2_ &&
//    a is { id: "a", .. } &&
//    b is { id: "b", .. },
//  )
//
//  // Test 2: Parse and transform `x += 5;` (compound assignment)
//  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2, s3] &&
//    s1 is Let(_, Int, Int(5)) &&
//    s2 is Let(_, Int, Binary(Add, _, _)) &&
//    s3 is Assign(name, Ident(_)) &&
//    name is { id: "x", .. },
//  )
//
//  // Test 3: Parse and transform `arr[0] = 42;` (array assignment)
//  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2] &&
//    s1 is Let(n1, Int, Int(0)) &&
//    s2 is ArrayPut(array_name, idx_name, Int(42)) &&
//    n1 == idx_name &&
//    array_name is { id: "arr", .. },
//  )
//
//  // Test 4: Parse and transform `point.x = 100;` (struct field assignment)
//  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(
//    knf_stmts is [s1, s2] &&
//    s1 is Let(n1, Int, Int(100)) &&
//    s2 is StructFieldSet(_, "x", value_name) &&
//    n1 == value_name,
//  )
//
//  // Test 5: Parse and transform `return;` (return without value)
//  let (stmt, _) = @parser.parse_stmt(tok_view)
//  let stmt = typecheck_ctx.check_stmt(stmt)
//  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
//  assert_true(knf_stmts is [s] && s is ReturnUnit)
//}

test "Stmt Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup struct definition for testing
  let point_struct_def : @typecheck.StructDef = {
    name: "Point",
    fields: [
      { name: "x", ty: { kind: Int, mutable: true } },
      { name: "y", ty: { kind: Int, mutable: true } },
    ],
    methods: Map::new(),
  }
  typecheck_ctx.struct_defs.set("Point", point_struct_def)

  // Set function context for return statement
  typecheck_ctx.current_func_ret_ty = Some(Struct("Point"))
  let code =
    #|let mut p = Point::{ x: 0, y: 0 };
    #|let mut a = 100;
    #|let (b, c) = (200, 300);
    #|let arr = [a, b, c];
    #|a *= 50;
    #|p.x += b + c;
    #|arr[1] = a - 25;
    #|return p;

  // Code parse, typecheck, knf transform
  let tokens = @lexer.tokenize(code)

  // Test 1: Parse and transform `let mut p = Point::{ mut x: 0, y: 0 };`
  let (stmt, tok_view) = @parser.parse_stmt(tokens)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(0)) &&
    s2 is Let(_, Int, Int(0)) &&
    s3 is LetMut(name, Struct("Point"), CreateStruct("Point", fields)) &&
    name is { id: "p", .. } &&
    fields is [field1, field2] &&
    field1 is ("x", _) &&
    field2 is ("y", _),
  )

  // Test 2: Parse and transform `let mut a = 100;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is LetMut(name, Int, Int(100)) &&
    name is { id: "a", .. },
  )

  // Test 3: Parse and transform `let (b, c) = (200, 300);`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3, s4] &&
    s1 is Let(n1, Int, Int(200)) &&
    s2 is Let(n2, Int, Int(300)) &&
    s3 is Let(b, _, Ident(n1_)) &&
    s4 is Let(c, _, Ident(n2_)) &&
    n1 == n1_ &&
    n2 == n2_ &&
    b is { id: "b", .. } &&
    c is { id: "c", .. },
  )

  // Test 4: Parse and transform `let arr = [a, b, c];`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Let(name, Array(Int), ArrayLiteral(_, elements)) &&
    name is { id: "arr", .. } &&
    elements is [elem1, elem2, elem3] &&
    elem1 is { id: "a", .. } &&
    elem2 is { id: "b", .. } &&
    elem3 is { id: "c", .. },
  )

  // Test 5: Parse and transform `a *= 50;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(50)) &&
    s2 is Let(_, Int, Binary(Mul, _, _)) &&
    s3 is Assign(name, Ident(_)) &&
    name is { id: "a", .. },
  )

  // Test 6: Parse and transform `p.x += b + c;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3, s4, s5] &&
    s1 is Let(n1, Int, FieldAccess(_, "x")) &&
    s2 is Let(n2, Int, Binary(Add, { id: "b", .. }, { id: "c", .. })) &&
    s3 is Let(n3, Int, Binary(Add, n1_, n2_)) &&
    s4 is Let(n4, Int, Ident(n3_)) &&
    s5 is StructFieldSet(_, "x", n4_) &&
    n1 == n1_ &&
    n2 == n2_ &&
    n3 == n3_ &&
    n4 == n4_,
  )

  // Test 7: Parse and transform `arr[1] = a - 25;`
  let (stmt, tok_view) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s1, s2, s3] &&
    s1 is Let(_, Int, Int(1)) &&
    s2 is Let(_, Int, Int(25)) &&
    s3 is ArrayPut(_),
  )

  // Test 8: Parse and transform `return p;`
  let (stmt, _) = @parser.parse_stmt(tok_view)
  let stmt = typecheck_ctx.check_stmt(stmt)
  let knf_stmts = knf_ctx.stmt_to_knf(stmt)
  assert_true(
    knf_stmts is [s] &&
    s is Return(return_expr) &&
    return_expr is Ident({ id: "p", .. }),
  )
}
/// ================================================================================
/// # ğŸ—ï¸ ç»“æ„ä½“å®šä¹‰çš„ KNF è½¬æ¢
///
/// ## ğŸ¯ ä»€ä¹ˆæ˜¯ç»“æ„ä½“å®šä¹‰ï¼Ÿ
///
/// ç»“æ„ä½“å®šä¹‰æ˜¯ç¼–ç¨‹è¯­è¨€ä¸­å®šä¹‰å¤åˆæ•°æ®ç±»å‹çš„æ–¹å¼ï¼Œå®ƒå…è®¸æˆ‘ä»¬å°†å¤šä¸ªç›¸å…³çš„æ•°æ®ç»„åˆåœ¨ä¸€èµ·ã€‚
/// ç»“æ„ä½“å®šä¹‰çš„åŸºæœ¬ç»“æ„æ˜¯ï¼š
/// struct StructName {
///   field1: Type1;
///   field2: Type2;
///   mut field3: Type3;
/// }
///
/// ç»“æ„ä½“å®šä¹‰çš„ç‰¹ç‚¹ï¼š
/// - å®šä¹‰äº†ä¸€ä¸ªæ–°çš„æ•°æ®ç±»å‹
/// - åŒ…å«å¤šä¸ªå­—æ®µï¼Œæ¯ä¸ªå­—æ®µæœ‰åç§°å’Œç±»å‹
/// - å­—æ®µå¯ä»¥æ˜¯å¯å˜çš„ï¼ˆmutï¼‰æˆ–ä¸å¯å˜çš„
/// - ç»“æ„ä½“å®šä¹‰æœ¬èº«ä¸äº§ç”Ÿè¿è¡Œæ—¶ä»£ç ï¼Œåªæ˜¯ç±»å‹å®šä¹‰
///
/// ## ğŸ” ç»“æ„å·®å¼‚åˆ†æ
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼Œç»“æ„ä½“å®šä¹‰çš„ç»“æ„ç›¸å¯¹ç®€å•ï¼š
/// - `name`: ç»“æ„ä½“åç§°ï¼ˆStringï¼‰
/// - `fields`: å­—æ®µåˆ—è¡¨ï¼ˆArray[StructField]ï¼‰
///
/// åœ¨ KNF ä¸­ï¼Œç»“æ„ä½“å®šä¹‰çš„ç»“æ„æ›´åŠ ç»Ÿä¸€ï¼š
/// - `KnfStructDef`: åŒ…å« name å’Œ fields çš„ç»“æ„ä½“
/// - `fields`: å­—æ®µåˆ—è¡¨ï¼Œæ¯ä¸ªå­—æ®µåŒ…å«ï¼ˆå­—æ®µåï¼Œæ˜¯å¦å¯å˜ï¼Œå­—æ®µç±»å‹ï¼‰
///
/// ## ğŸ› ï¸ å®ç°æ€è·¯
///
/// å®ç° `struct_def_to_knf` å‡½æ•°éœ€è¦ä¸¤ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. å­—æ®µè½¬æ¢
/// - éå†ç»“æ„ä½“çš„æ‰€æœ‰å­—æ®µ
/// - å¯¹æ¯ä¸ªå­—æ®µï¼Œæå–å­—æ®µåã€å¯å˜æ€§å’Œç±»å‹
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢å­—æ®µç±»å‹
/// - å°†å­—æ®µä¿¡æ¯å­˜å‚¨ä¸ºï¼ˆå­—æ®µåï¼Œæ˜¯å¦å¯å˜ï¼Œå­—æ®µç±»å‹ï¼‰çš„å…ƒç»„
///
/// ### 2. æ„é€ ç»“æ„ä½“å®šä¹‰
/// - åˆ›å»º `KnfStructDef` ç»“æ„
/// - è®¾ç½®ç»“æ„ä½“åç§°å’Œè½¬æ¢åçš„å­—æ®µåˆ—è¡¨
/// - è¿”å›è½¬æ¢åçš„ç»“æ„ä½“å®šä¹‰
///
/// ## ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// ### å­—æ®µä¿¡æ¯æå–
/// ä» `StructField` ä¸­æå–å­—æ®µä¿¡æ¯ï¼š
/// - `name`: å­—æ®µåç§°
/// - `ty.kind`: å­—æ®µç±»å‹
/// - `ty.mutable`: å­—æ®µæ˜¯å¦å¯å˜
///
/// ### ç±»å‹è½¬æ¢
/// ä½¿ç”¨ `typekind_to_knf` å°†å­—æ®µç±»å‹è½¬æ¢ä¸º KNF ç±»å‹ï¼š
/// - Int -> Int
/// - String -> String
/// - Double -> Double
/// - å…¶ä»–ç±»å‹æŒ‰éœ€è½¬æ¢
///
/// ### å­—æ®µå­˜å‚¨
/// å°†å­—æ®µä¿¡æ¯å­˜å‚¨ä¸ºå…ƒç»„æ ¼å¼ï¼š
/// (å­—æ®µå: String, æ˜¯å¦å¯å˜: Bool, å­—æ®µç±»å‹: Type)
///
/// ## ğŸ“ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å•ç»“æ„ä½“
/// struct Point {
///   x: Int;
///   y: Int;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. ç»“æ„ä½“åç§°ï¼šPoint
/// 2. å­—æ®µåˆ—è¡¨ï¼š[(x, false, Int), (y, false, Int)]
/// 3. è¿”å› KnfStructDef { name: "Point", fields: [...] }
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šåŒ…å«å¯å˜å­—æ®µçš„ç»“æ„ä½“
/// struct Person {
///   name: String;
///   age: Int;
///   mut score: Double;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. ç»“æ„ä½“åç§°ï¼šPerson
/// 2. å­—æ®µåˆ—è¡¨ï¼š[(name, false, String), (age, false, Int), (score, true, Double)]
/// 3. è¿”å› KnfStructDef { name: "Person", fields: [...] }
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼šç©ºç»“æ„ä½“
/// struct Empty {}
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. ç»“æ„ä½“åç§°ï¼šEmpty
/// 2. å­—æ®µåˆ—è¡¨ï¼š[]
/// 3. è¿”å› KnfStructDef { name: "Empty", fields: [] }
///
/// ## ğŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### ç±»å‹å®šä¹‰
/// ç»“æ„ä½“å®šä¹‰æ˜¯ç±»å‹å®šä¹‰ï¼Œä¸äº§ç”Ÿè¿è¡Œæ—¶ä»£ç ï¼Œåªæ˜¯å®šä¹‰æ•°æ®ç»“æ„ã€‚
///
/// ### å­—æ®µä¿¡æ¯ä¿ç•™
/// ä¿ç•™å­—æ®µçš„å®Œæ•´ä¿¡æ¯ï¼ŒåŒ…æ‹¬åç§°ã€å¯å˜æ€§å’Œç±»å‹ã€‚
///
/// ### ç±»å‹ç»Ÿä¸€
/// å°†å­—æ®µç±»å‹è½¬æ¢ä¸ºç»Ÿä¸€çš„ KNF ç±»å‹è¡¨ç¤ºã€‚
///
/// ### ç»“æ„ç®€åŒ–
/// åœ¨ KNF ä¸­ç®€åŒ–ç»“æ„ä½“å®šä¹‰çš„è¡¨ç¤ºï¼Œä¾¿äºåç»­å¤„ç†ã€‚
///
/// ## ğŸš€ å®ç°æŒ‘æˆ˜
///
/// ### å­—æ®µéå†
/// éœ€è¦æ­£ç¡®éå†ç»“æ„ä½“çš„æ‰€æœ‰å­—æ®µã€‚
///
/// ### ç±»å‹è½¬æ¢
/// éœ€è¦æ­£ç¡®è½¬æ¢å­—æ®µç±»å‹ä¸º KNF ç±»å‹ã€‚
///
/// ### ä¿¡æ¯æå–
/// éœ€è¦æ­£ç¡®æå–å­—æ®µçš„åç§°ã€å¯å˜æ€§å’Œç±»å‹ä¿¡æ¯ã€‚
///
/// ## ğŸ¯ å®ç°ç›®æ ‡
///
/// å®Œæˆ `struct_def.mbt` ä¸­çš„ `struct_def_to_knf` å‡½æ•°ï¼Œå®ç°ç»“æ„ä½“å®šä¹‰çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®éå†ç»“æ„ä½“çš„æ‰€æœ‰å­—æ®µ
/// 2. æ­£ç¡®æå–å­—æ®µçš„åç§°ã€å¯å˜æ€§å’Œç±»å‹ä¿¡æ¯
/// 3. æ­£ç¡®è½¬æ¢å­—æ®µç±»å‹ä¸º KNF ç±»å‹
/// 4. è¿”å›ç»Ÿä¸€çš„ KnfStructDef ç»“æ„
///
/// ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®ç°ç»“æ„ä½“å®šä¹‰çš„è½¬æ¢å§ï¼ğŸš€
///
/// ================================================================================

///|
test "Struct Def Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Put all code together
  let code =
    #|struct Point {
    #|  x: Int;
    #|  y: Int;
    #|}
    #|struct Person {
    #|  name: String;
    #|  age: Int;
    #|  mut score: Double;
    #|}
    #|struct Empty {}
  let tokens = @lexer.tokenize(code)

  // Test 1: Simple struct with two immutable fields
  let (struct_def1, tok_view) = @parser.parse_struct_def(tokens)
  let checked_struct_def1 = typecheck_ctx.check_struct_def(struct_def1)
  let knf_struct_def1 = knf_ctx.struct_def_to_knf(checked_struct_def1)
  assert_true(knf_struct_def1.name == "Point")
  assert_true(knf_struct_def1.fields.length() is 2)
  assert_true(
    knf_struct_def1.fields[0] is (field_name1, is_mut1, field_type1) &&
    field_name1 == "x" &&
    is_mut1 == false &&
    field_type1 is Int,
  )
  assert_true(
    knf_struct_def1.fields[1] is (field_name2, is_mut2, field_type2) &&
    field_name2 == "y" &&
    is_mut2 == false &&
    field_type2 is Int,
  )

  // Test 2: Struct with mutable field
  let (struct_def2, tok_view) = @parser.parse_struct_def(tok_view)
  let checked_struct_def2 = typecheck_ctx.check_struct_def(struct_def2)
  let knf_struct_def2 = knf_ctx.struct_def_to_knf(checked_struct_def2)
  assert_true(knf_struct_def2.name == "Person")
  assert_true(knf_struct_def2.fields.length() is 3)
  assert_true(
    knf_struct_def2.fields[0] is (field_name3, is_mut3, field_type3) &&
    field_name3 == "name" &&
    is_mut3 == false &&
    field_type3 is String,
  )
  assert_true(
    knf_struct_def2.fields[1] is (field_name4, is_mut4, field_type4) &&
    field_name4 == "age" &&
    is_mut4 == false &&
    field_type4 is Int,
  )
  assert_true(
    knf_struct_def2.fields[2] is (field_name5, is_mut5, field_type5) &&
    field_name5 == "score" &&
    is_mut5 == true &&
    field_type5 is Double,
  )

  // Test 3: Empty struct
  let (struct_def3, _) = @parser.parse_struct_def(tok_view)
  let checked_struct_def3 = typecheck_ctx.check_struct_def(struct_def3)
  let knf_struct_def3 = knf_ctx.struct_def_to_knf(checked_struct_def3)
  assert_true(knf_struct_def3.name == "Empty")
  assert_true(knf_struct_def3.fields.is_empty())
}
/// ================================================================================
/// # ğŸ”§ é¡¶å±‚å‡½æ•°çš„ KNF è½¬æ¢
///
/// ## ğŸ¯ ä»€ä¹ˆæ˜¯é¡¶å±‚å‡½æ•°ï¼Ÿ
///
/// é¡¶å±‚å‡½æ•°æ˜¯ç¨‹åºä¸­æœ€é¡¶å±‚çš„å‡½æ•°å®šä¹‰ï¼Œå®ƒä»¬å®šä¹‰å…¨å±€å¯è°ƒç”¨çš„å‡½æ•°ã€‚
/// é¡¶å±‚å‡½æ•°çš„åŸºæœ¬ç»“æ„æ˜¯ï¼š
/// fn function_name(param1: Type1, param2: Type2) -> ReturnType {
///   // å‡½æ•°ä½“
/// }
///
/// é¡¶å±‚å‡½æ•°çš„ç‰¹ç‚¹ï¼š
/// - å®šä¹‰äº†ä¸€ä¸ªæ–°çš„å‡½æ•°
/// - åŒ…å«å‚æ•°åˆ—è¡¨ã€è¿”å›ç±»å‹å’Œå‡½æ•°ä½“
/// - å‡½æ•°ä½“æ˜¯ä¸€ä¸ª BlockExpr
/// - éœ€è¦åœ¨å…¨å±€ä½œç”¨åŸŸä¸­æ³¨å†Œå‡½æ•°ç­¾å
/// - å‡½æ•°å‚æ•°åœ¨å‡½æ•°ä½œç”¨åŸŸä¸­å®šä¹‰
///
/// ## ğŸ” ç»“æ„å·®å¼‚åˆ†æ
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼Œé¡¶å±‚å‡½æ•°çš„ç»“æ„ç›¸å¯¹ç®€å•ï¼š
/// - `fname`: å‡½æ•°åç§°ï¼ˆStringï¼‰
/// - `param_list`: å‚æ•°åˆ—è¡¨ï¼ˆArray[Param]ï¼‰
/// - `ret_ty`: è¿”å›ç±»å‹ï¼ˆTypeKindï¼‰
/// - `body`: å‡½æ•°ä½“ï¼ˆBlockExprï¼‰
///
/// åœ¨ KNF ä¸­ï¼Œé¡¶å±‚å‡½æ•°çš„ç»“æ„æ›´åŠ ç»Ÿä¸€ï¼š
/// - `KnfFunction`: åŒ…å« nameã€ret_tyã€paramsã€body çš„ç»“æ„ä½“
/// - `params`: å‚æ•°åˆ—è¡¨ï¼Œæ¯ä¸ªå‚æ•°åŒ…å«ï¼ˆNameï¼ŒTypeï¼‰
/// - `body`: å‡½æ•°ä½“ï¼ˆKnfBlockï¼‰
///
/// ## ğŸ› ï¸ å®ç°æ€è·¯
///
/// å®ç° `top_function_to_knf` å‡½æ•°éœ€è¦äº”ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. è¿›å…¥å‡½æ•°ä½œç”¨åŸŸ
/// - ä½¿ç”¨ `enter_scope()` åˆ›å»ºæ–°çš„ä½œç”¨åŸŸ
/// - ä¸ºå‡½æ•°å‚æ•°å’Œå±€éƒ¨å˜é‡æä¾›ç‹¬ç«‹çš„ä½œç”¨åŸŸ
///
/// ### 2. å‚æ•°å¤„ç†
/// - éå†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢å‚æ•°ç±»å‹
/// - å°†å‚æ•°æ³¨å†Œåˆ°å½“å‰ä½œç”¨åŸŸä¸­
/// - æ”¶é›†å‚æ•°ä¿¡æ¯ç”¨äºå‡½æ•°ç±»å‹æ„é€ 
///
/// ### 3. è¿”å›ç±»å‹è½¬æ¢
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢è¿”å›ç±»å‹
/// - æ„é€ å‡½æ•°ç±»å‹ `Function(param_types, ret_ty)`
///
/// ### 4. å‡½æ•°ä½“è½¬æ¢
/// - ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢å‡½æ•°ä½“
/// - å‡½æ•°ä½“ä¸­çš„æ‰€æœ‰è¯­å¥éƒ½åœ¨å‡½æ•°ä½œç”¨åŸŸä¸­å¤„ç†
///
/// ### 5. é€€å‡ºä½œç”¨åŸŸå¹¶æ³¨å†Œ
/// - ä½¿ç”¨ `exit_scope()` é€€å‡ºå‡½æ•°ä½œç”¨åŸŸ
/// - å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸä¸­
/// - è¿”å› `KnfFunction` ç»“æ„
///
/// ## ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// ### ä½œç”¨åŸŸç®¡ç†
/// é¡¶å±‚å‡½æ•°çš„è½¬æ¢éœ€è¦è°¨æ…ç®¡ç†ä½œç”¨åŸŸï¼š
/// - åœ¨å¼€å§‹å¤„ç†å‚æ•°å‰è¿›å…¥ä½œç”¨åŸŸ
/// - åœ¨å‡½æ•°ä½“è½¬æ¢å®Œæˆåé€€å‡ºä½œç”¨åŸŸ
/// - ç¡®ä¿å‚æ•°å’Œå±€éƒ¨å˜é‡åœ¨æ­£ç¡®çš„ä½œç”¨åŸŸä¸­
///
/// ### å‚æ•°å¤„ç†
/// ä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name å¹¶æ³¨å†Œåˆ°ä½œç”¨åŸŸï¼š
/// fn add(x: Int, y: Int) -> Int { ... }
/// è½¬æ¢ä¸ºï¼š
/// - åˆ›å»º Name { id: "x", slot: 0 } å’Œ Name { id: "y", slot: 0 }
/// - æ³¨å†Œåˆ°å½“å‰ä½œç”¨åŸŸ
/// - æ”¶é›†å‚æ•°ç±»å‹ç”¨äºå‡½æ•°ç±»å‹æ„é€ 
///
/// ### å‡½æ•°ç±»å‹æ„é€ 
/// æ„é€ å‡½æ•°ç±»å‹ç”¨äºå…¨å±€æ³¨å†Œï¼š
/// - å‚æ•°ç±»å‹åˆ—è¡¨ï¼š[Int, Int]
/// - è¿”å›ç±»å‹ï¼šInt
/// - å‡½æ•°ç±»å‹ï¼šFunction([Int, Int], Int)
///
/// ### å…¨å±€æ³¨å†Œ
/// å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼š
/// - ä½¿ç”¨å‡½æ•°åä½œä¸ºé”®
/// - ä½¿ç”¨å‡½æ•°ç±»å‹ä½œä¸ºå€¼
/// - ç¡®ä¿å‡½æ•°å¯ä»¥è¢«å…¶ä»–ä»£ç è°ƒç”¨
///
/// ## ğŸ“ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å•å‡½æ•°
/// fn add(x: Int, y: Int) -> Int {
///   return x + y;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼šx, y
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šreturn x + y;
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šUnit è¿”å›ç±»å‹
/// fn greet(name: String) -> Unit {
///   return ();
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼šname
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šreturn ();
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼šé€’å½’å‡½æ•°
/// fn fib(n: Int) -> Int {
///   if n <= 1 {
///     return n;
///   } else {
///     return fib(n - 1) + fib(n - 2);
///   }
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼šn
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šif è¡¨è¾¾å¼å’Œé€’å½’è°ƒç”¨
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 4ï¼šå¤šè¯­å¥å‡½æ•°
/// fn compute(a: Int, b: Int, c: Int) -> Int {
///   let sum = a + b;
///   let result = sum * c;
///   return result;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¿›å…¥ä½œç”¨åŸŸ
/// 2. å¤„ç†å‚æ•°ï¼ša, b, c
/// 3. è½¬æ¢å‡½æ•°ä½“ï¼šlet è¯­å¥å’Œ return è¯­å¥
/// 4. é€€å‡ºä½œç”¨åŸŸ
/// 5. æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
///
/// ## ğŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### ä½œç”¨åŸŸéš”ç¦»
/// æ¯ä¸ªå‡½æ•°éƒ½æœ‰ç‹¬ç«‹çš„ä½œç”¨åŸŸï¼Œå‚æ•°å’Œå±€éƒ¨å˜é‡ä¸ä¼šç›¸äº’å¹²æ‰°ã€‚
///
/// ### å‚æ•°ç®¡ç†
/// å‚æ•°åœ¨å‡½æ•°ä½œç”¨åŸŸä¸­å®šä¹‰ï¼Œå¯ä»¥è¢«å‡½æ•°ä½“ä¸­çš„è¯­å¥ä½¿ç”¨ã€‚
///
/// ### å…¨å±€æ³¨å†Œ
/// å‡½æ•°å®šä¹‰åéœ€è¦æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä¾›å…¶ä»–ä»£ç è°ƒç”¨ã€‚
///
/// ### ç±»å‹å®‰å…¨
/// ç¡®ä¿å‡½æ•°å‚æ•°å’Œè¿”å›ç±»å‹çš„ç±»å‹å®‰å…¨ã€‚
///
/// ## ğŸš€ å®ç°æŒ‘æˆ˜
///
/// ### ä½œç”¨åŸŸæ—¶æœº
/// éœ€è¦è°¨æ…å†³ç­–è¿›å…¥ä½œç”¨åŸŸå’Œé€€å‡ºä½œç”¨åŸŸçš„æ—¶æœºï¼š
/// - åœ¨å‚æ•°å¤„ç†å‰è¿›å…¥ä½œç”¨åŸŸ
/// - åœ¨å‡½æ•°ä½“è½¬æ¢å®Œæˆåé€€å‡ºä½œç”¨åŸŸ
/// - ç¡®ä¿å…¨å±€æ³¨å†Œåœ¨ä½œç”¨åŸŸå¤–è¿›è¡Œ
///
/// ### å‚æ•°å¤„ç†
/// éœ€è¦æ­£ç¡®å¤„ç†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name å¹¶æ³¨å†Œåˆ°ä½œç”¨åŸŸã€‚
///
/// ### å‡½æ•°ç±»å‹æ„é€ 
/// éœ€è¦æ­£ç¡®æ„é€ å‡½æ•°ç±»å‹ï¼ŒåŒ…æ‹¬å‚æ•°ç±»å‹åˆ—è¡¨å’Œè¿”å›ç±»å‹ã€‚
///
/// ### å…¨å±€æ³¨å†Œ
/// éœ€è¦å°†å‡½æ•°æ­£ç¡®æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼Œç¡®ä¿å‡½æ•°å¯ä»¥è¢«è°ƒç”¨ã€‚
///
/// ## ğŸ¯ å®ç°ç›®æ ‡
///
/// å®Œæˆ `function.mbt` ä¸­çš„ `top_function_to_knf` å‡½æ•°ï¼Œå®ç°é¡¶å±‚å‡½æ•°çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®ç®¡ç†å‡½æ•°ä½œç”¨åŸŸï¼ˆenter_scope å’Œ exit_scopeï¼‰
/// 2. æ­£ç¡®å¤„ç†å‚æ•°åˆ—è¡¨ï¼Œä¸ºæ¯ä¸ªå‚æ•°åˆ›å»º Name
/// 3. æ­£ç¡®è½¬æ¢å‚æ•°ç±»å‹å’Œè¿”å›ç±»å‹
/// 4. æ­£ç¡®è½¬æ¢å‡½æ•°ä½“ä¸º KNF
/// 5. å°†å‡½æ•°æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
/// 6. è¿”å›ç»Ÿä¸€çš„ KnfFunction ç»“æ„
///
/// ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®ç°é¡¶å±‚å‡½æ•°çš„è½¬æ¢å§ï¼ğŸš€
///
/// ================================================================================

///|
test "Top Function Knf Transformation Test - 2" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup builtin functions
  typecheck_ctx.func_types.set("print_int", Function([Int], Unit))
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })
  knf_ctx.globals.set("print_int", Function([Int], Unit))
  let code =
    #|fn add(x: Int, y: Int) -> Int {
    #|  return x + y;
    #|}
    #|fn greet(name: String) -> Unit {
    #|  return ();
    #|}
    #|fn fib(n: Int) -> Int {
    #|  if n <= 1 {
    #|    return n;
    #|  } else {
    #|    return fib(n - 1) + fib(n - 2);
    #|  }
    #|}
    #|fn compute(a: Int, b: Int, c: Int) -> Int {
    #|  let sum = a + b;
    #|  let result = sum * c;
    #|  return result;
    #|}

  // Register function signatures first
  typecheck_ctx.func_types.set("add", Function([Int, Int], Int))
  typecheck_ctx.type_env.set("add", {
    kind: Function([Int, Int], Int),
    mutable: false,
  })
  typecheck_ctx.func_types.set("greet", Function([String], Unit))
  typecheck_ctx.type_env.set("greet", {
    kind: Function([String], Unit),
    mutable: false,
  })
  typecheck_ctx.func_types.set("fib", Function([Int], Int))
  typecheck_ctx.type_env.set("fib", {
    kind: Function([Int], Int),
    mutable: false,
  })
  typecheck_ctx.func_types.set("compute", Function([Int, Int, Int], Int))
  typecheck_ctx.type_env.set("compute", {
    kind: Function([Int, Int, Int], Int),
    mutable: false,
  })
  let tokens = @lexer.tokenize(code)

  // Test 1: Simple function with two parameters and return
  let (top_func1, tok_view) = @parser.parse_top_function(tokens)
  let checked_func1 = typecheck_ctx.check_top_function(top_func1)
  let knf_func1 = knf_ctx.top_function_to_knf(checked_func1)
  assert_true(knf_func1.name == "add")
  assert_true(knf_func1.ret_ty is Int)
  assert_true(knf_func1.params.length() is 2)
  assert_true(
    knf_func1.params[0] is (param_name1, param_type1) &&
    param_name1 is { id: "x", slot: 0 } &&
    param_type1 is Int,
  )
  assert_true(
    knf_func1.params[1] is (param_name2, param_type2) &&
    param_name2 is { id: "y", slot: 0 } &&
    param_type2 is Int,
  )
  // Body should have: return x + y;
  assert_true(knf_func1.body.stmts.length() is 1)
  assert_true(
    knf_func1.body.stmts is [s] &&
    s is Return(Binary(Add, x_name, y_name)) &&
    x_name is { id: "x", .. } &&
    y_name is { id: "y", .. },
  )

  // Test 2: Function with String parameter returning Unit
  let (top_func2, tok_view) = @parser.parse_top_function(tok_view)
  let checked_func2 = typecheck_ctx.check_top_function(top_func2)
  let knf_func2 = knf_ctx.top_function_to_knf(checked_func2)
  assert_true(knf_func2.name == "greet")
  assert_true(knf_func2.ret_ty is Unit)
  assert_true(knf_func2.params.length() is 1)
  assert_true(
    knf_func2.params is [(param_name3, param_type3)] &&
    param_name3 is { id: "name", slot: 0 } &&
    param_type3 is String,
  )
  // Body should have: return ();
  assert_true(knf_func2.body.stmts.length() is 1)
  assert_true(knf_func2.body.stmts[0] is Return(Unit))

  // Test 3: Recursive function with if expression
  let (top_func3, tok_view) = @parser.parse_top_function(tok_view)
  let checked_func3 = typecheck_ctx.check_top_function(top_func3)
  let knf_func3 = knf_ctx.top_function_to_knf(checked_func3)
  assert_true(knf_func3.name == "fib")
  assert_true(knf_func3.ret_ty is Int)
  assert_true(knf_func3.params.length() is 1)
  assert_true(
    knf_func3.params[0] is (param_name4, param_type4) &&
    param_name4 is { id: "n", slot: 0 } &&
    param_type4 is Int,
  )
  // Body should contain if expression and recursive calls
  // We don't need to verify the exact structure, just that it's transformed
  assert_true(knf_func3.body.stmts.length() > 0)

  // Test 4: Function with multiple statements in body
  let (top_func4, _) = @parser.parse_top_function(tok_view)
  let checked_func4 = typecheck_ctx.check_top_function(top_func4)
  let knf_func4 = knf_ctx.top_function_to_knf(checked_func4)
  assert_true(knf_func4.name == "compute")
  assert_true(knf_func4.ret_ty is Int)
  assert_true(knf_func4.params.length() is 3)
  // Body should have: let sum = a + b; let result = sum * c; return result;
  assert_true(knf_func4.body.stmts.length() is 3)
  assert_true(
    knf_func4.body.stmts[0] is Let(sum_name, Int, Binary(Add, a_name, b_name)) &&
    sum_name is { id: "sum", .. } &&
    a_name is { id: "a", .. } &&
    b_name is { id: "b", .. },
  )
  assert_true(
    knf_func4.body.stmts[1]
    is Let(result_name, Int, Binary(Mul, sum_name2, c_name)) &&
    result_name is { id: "result", .. } &&
    sum_name2 is { id: "sum", .. } &&
    c_name is { id: "c", .. },
  )
  assert_true(
    knf_func4.body.stmts[2] is Return(Ident(result_name2)) &&
    result_name2 is { id: "result", .. },
  )
}
/// ================================================================================
/// # ğŸŒ é¡¶å±‚ Let è¯­å¥çš„ KNF è½¬æ¢
///
/// ## ğŸ¯ ä»€ä¹ˆæ˜¯é¡¶å±‚ Let è¯­å¥ï¼Ÿ
///
/// é¡¶å±‚ Let è¯­å¥æ˜¯ç¨‹åºä¸­æœ€é¡¶å±‚çš„å˜é‡å£°æ˜ï¼Œå®ƒä»¬å®šä¹‰å…¨å±€å˜é‡å’Œå¸¸é‡ã€‚
/// é¡¶å±‚ Let è¯­å¥çš„åŸºæœ¬ç»“æ„æ˜¯ï¼š
/// let variable_name: Type = expression;
///
/// ä¸å‡½æ•°å†…çš„ Let è¯­å¥ä¸åŒï¼Œé¡¶å±‚ Let è¯­å¥ï¼š
/// - å·¦è¾¹ä¸æ˜¯æ¨¡å¼ï¼ˆPatternï¼‰ï¼Œè€Œæ˜¯ç®€å•çš„æ ‡è¯†ç¬¦
/// - å£°æ˜çš„æ˜¯å…¨å±€å˜é‡ï¼Œéœ€è¦åœ¨å…¨å±€ä½œç”¨åŸŸä¸­æ³¨å†Œ
/// - è½¬æ¢å®Œæˆåéœ€è¦æ³¨å†Œåˆ° Context çš„ globals å­—æ®µä¸­
///
/// ## ğŸ” ç»“æ„å·®å¼‚åˆ†æ
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼Œé¡¶å±‚ Let è¯­å¥çš„ç»“æ„ç›¸å¯¹ç®€å•ï¼š
/// - `name`: å˜é‡åï¼ˆStringï¼‰
/// - `ty`: ç±»å‹ï¼ˆTypeï¼‰
/// - `expr`: åˆå§‹åŒ–è¡¨è¾¾å¼ï¼ˆExprï¼‰
///
/// ä½†åœ¨ KNF ä¸­ï¼Œé¡¶å±‚ Let è¯­å¥çš„ç»“æ„æ›´åŠ ç»Ÿä¸€ï¼š
/// - `KnfTopLet`: åŒ…å« nameã€tyã€expr çš„ç»“æ„ä½“
/// - å˜é‡åè¢«è½¬æ¢ä¸º `Name` ç»“æ„
/// - ç±»å‹è¢«è½¬æ¢ä¸º KNF ç±»å‹
/// - è¡¨è¾¾å¼è¢«è½¬æ¢ä¸º KNF è¡¨è¾¾å¼
///
/// ## ğŸ› ï¸ å®ç°æ€è·¯
///
/// å®ç° `top_let_to_knf` å‡½æ•°éœ€è¦å››ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. è¡¨è¾¾å¼è½¬æ¢
/// - ä½¿ç”¨ `expr_to_knf` è½¬æ¢åˆå§‹åŒ–è¡¨è¾¾å¼
/// - æ”¶é›†è¡¨è¾¾å¼è½¬æ¢è¿‡ç¨‹ä¸­äº§ç”Ÿçš„è¯­å¥
///
/// ### 2. ç±»å‹è½¬æ¢
/// - ä½¿ç”¨ `typekind_to_knf` è½¬æ¢ç±»å‹
/// - ç¡®ä¿ç±»å‹ä¸€è‡´æ€§
///
/// ### 3. é‡å¤å£°æ˜æ£€æŸ¥
/// - æ£€æŸ¥ globals ä¸­æ˜¯å¦å·²å­˜åœ¨åŒåå˜é‡
/// - å¦‚æœå­˜åœ¨ï¼ŒæŠ›å‡ºé‡å¤å£°æ˜é”™è¯¯
///
/// ### 4. å…¨å±€æ³¨å†Œ
/// - ä½¿ç”¨ `add_new_name` åˆ›å»ºæ–°çš„ Name
/// - å°†å˜é‡æ³¨å†Œåˆ° globals å­—æ®µä¸­
/// - è¿”å› `KnfTopLet` ç»“æ„
///
/// ## ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// ### å…¨å±€å˜é‡ç®¡ç†
/// é¡¶å±‚ Let è¯­å¥å£°æ˜çš„å˜é‡éœ€è¦æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸï¼š
/// let x: Int = 42;
/// è½¬æ¢ä¸ºï¼š
/// - åˆ›å»º Name { id: "x", slot: 0 }
/// - æ³¨å†Œåˆ° globals["x"] = Int
/// - è¿”å› KnfTopLet { name, ty: Int, expr: Int(42) }
///
/// ### é‡å¤å£°æ˜æ£€æŸ¥
/// åœ¨æ³¨å†Œå…¨å±€å˜é‡ä¹‹å‰ï¼Œéœ€è¦æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼š
/// guard self.globals.get(top_let.name) is None else {
///   raise KnfTransformError("Duplicate global variable declaration: ...")
/// }
///
/// ### è¡¨è¾¾å¼å¤„ç†
/// åˆå§‹åŒ–è¡¨è¾¾å¼å¯èƒ½åŒ…å«å¤æ‚çš„è®¡ç®—ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸º KNFï¼š
/// let sum = a + b;
/// è½¬æ¢ä¸ºï¼š
/// - è¡¨è¾¾å¼ a + b è½¬æ¢ä¸º KNF
/// - åˆ›å»ºå…¨å±€å˜é‡ sum
/// - æ³¨å†Œåˆ° globals
///
/// ### ç±»å‹ä¸€è‡´æ€§
/// ç¡®ä¿å£°æ˜çš„ç±»å‹ä¸è¡¨è¾¾å¼çš„ç±»å‹ä¸€è‡´ï¼š
/// - å¦‚æœæä¾›äº†ç±»å‹æ³¨è§£ï¼Œéœ€è¦éªŒè¯ç±»å‹å…¼å®¹æ€§
/// - å¦‚æœæ²¡æœ‰ç±»å‹æ³¨è§£ï¼Œä½¿ç”¨è¡¨è¾¾å¼çš„æ¨æ–­ç±»å‹
///
/// ## ğŸ“ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å•ç±»å‹æ³¨è§£
/// let x: Int = 42;
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¡¨è¾¾å¼ 42 è½¬æ¢ä¸º Int(42)
/// 2. ç±»å‹ Int ä¿æŒä¸å˜
/// 3. åˆ›å»º Name { id: "x", slot: 0 }
/// 4. æ³¨å†Œåˆ° globals["x"] = Int
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šç±»å‹æ¨æ–­
/// let y = 3.14;
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¡¨è¾¾å¼ 3.14 è½¬æ¢ä¸º Double(3.14)
/// 2. æ¨æ–­ç±»å‹ä¸º Double
/// 3. åˆ›å»º Name { id: "y", slot: 0 }
/// 4. æ³¨å†Œåˆ° globals["y"] = Double
///
/// ### æµ‹è¯•ç”¨ä¾‹ 3ï¼šå­—ç¬¦ä¸²ç±»å‹
/// let s: String = "hello";
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¡¨è¾¾å¼ "hello" è½¬æ¢ä¸º String("hello")
/// 2. ç±»å‹ String ä¿æŒä¸å˜
/// 3. åˆ›å»º Name { id: "s", slot: 0 }
/// 4. æ³¨å†Œåˆ° globals["s"] = String
///
/// ### æµ‹è¯•ç”¨ä¾‹ 4ï¼šå¤æ‚è¡¨è¾¾å¼
/// let sum = a + b;
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. è¡¨è¾¾å¼ a + b è½¬æ¢ä¸º Binary(Add, a_name, b_name)
/// 2. æ¨æ–­ç±»å‹ä¸º Int
/// 3. åˆ›å»º Name { id: "sum", slot: 0 }
/// 4. æ³¨å†Œåˆ° globals["sum"] = Int
///
/// ## ğŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### å…¨å±€ä½œç”¨åŸŸç®¡ç†
/// é¡¶å±‚ Let è¯­å¥å£°æ˜çš„å˜é‡å±äºå…¨å±€ä½œç”¨åŸŸï¼Œéœ€è¦ç»Ÿä¸€ç®¡ç†ã€‚
///
/// ### é‡å¤å£°æ˜é˜²æŠ¤
/// é€šè¿‡æ£€æŸ¥ globals å­—æ®µï¼Œé˜²æ­¢é‡å¤å£°æ˜å…¨å±€å˜é‡ã€‚
///
/// ### ç±»å‹å®‰å…¨
/// ç¡®ä¿å£°æ˜çš„ç±»å‹ä¸è¡¨è¾¾å¼çš„ç±»å‹ä¸€è‡´ï¼Œä¿è¯ç±»å‹å®‰å…¨ã€‚
///
/// ### ç»Ÿä¸€ç»“æ„
/// å°†é¡¶å±‚ Let è¯­å¥è½¬æ¢ä¸ºç»Ÿä¸€çš„ KnfTopLet ç»“æ„ï¼Œä¾¿äºåç»­å¤„ç†ã€‚
///
/// ## ğŸš€ å®ç°æŒ‘æˆ˜
///
/// ### å…¨å±€å˜é‡ç®¡ç†
/// éœ€è¦æ­£ç¡®ç®¡ç†å…¨å±€å˜é‡çš„æ³¨å†Œå’ŒæŸ¥æ‰¾ï¼Œé¿å…å‘½åå†²çªã€‚
///
/// ### ç±»å‹ä¸€è‡´æ€§æ£€æŸ¥
/// éœ€è¦ç¡®ä¿å£°æ˜çš„ç±»å‹ä¸è¡¨è¾¾å¼çš„ç±»å‹ä¸€è‡´ã€‚
///
/// ### é‡å¤å£°æ˜å¤„ç†
/// éœ€è¦æ£€æŸ¥å¹¶é˜²æ­¢é‡å¤å£°æ˜å…¨å±€å˜é‡ã€‚
///
/// ### è¡¨è¾¾å¼å¤æ‚æ€§
/// åˆå§‹åŒ–è¡¨è¾¾å¼å¯èƒ½åŒ…å«å¤æ‚çš„è®¡ç®—ï¼Œéœ€è¦æ­£ç¡®è½¬æ¢ä¸º KNFã€‚
///
/// ## ğŸ¯ å®ç°ç›®æ ‡
///
/// å®Œæˆ `top_let.mbt` ä¸­çš„ `top_let_to_knf` å‡½æ•°ï¼Œå®ç°é¡¶å±‚ Let è¯­å¥çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®è½¬æ¢åˆå§‹åŒ–è¡¨è¾¾å¼ä¸º KNF
/// 2. æ­£ç¡®è½¬æ¢ç±»å‹ä¸º KNF ç±»å‹
/// 3. æ£€æŸ¥é‡å¤å£°æ˜å¹¶é˜²æ­¢å†²çª
/// 4. å°†å˜é‡æ³¨å†Œåˆ°å…¨å±€ä½œç”¨åŸŸ
/// 5. è¿”å›ç»Ÿä¸€çš„ KnfTopLet ç»“æ„
///
/// ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®ç°é¡¶å±‚ Let è¯­å¥çš„è½¬æ¢å§ï¼ğŸš€
///
/// ================================================================================

///|
test "Top Let Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Test 1: Simple top-level let with type annotation: let x: Int = 42;
  let code =
    #|let x: Int = 42;
    #|let y = 3.14;
    #|let s: String = "hello";
    #|let a = 1;
    #|let b = 2;
    #|let sum = a + b;
  let tokens1 = @lexer.tokenize(code)
  // Test 1: Check the structure
  let (top_let1, tok_view) = @parser.parse_top_let(tokens1)
  let checked_top_let1 = typecheck_ctx.check_top_let(top_let1)
  let knf_top_let1 = knf_ctx.top_let_to_knf(checked_top_let1)
  assert_true(
    knf_top_let1.name is { id: "x", slot: 0 } &&
    knf_top_let1.ty is Int &&
    knf_top_let1.expr is Int(42),
  )

  // Test 2: Check the structure
  let (top_let2, tok_view) = @parser.parse_top_let(tok_view)
  let checked_top_let2 = typecheck_ctx.check_top_let(top_let2)
  let knf_top_let2 = knf_ctx.top_let_to_knf(checked_top_let2)
  assert_true(
    knf_top_let2.name is { id: "y", slot: 0 } &&
    knf_top_let2.ty is Double &&
    knf_top_let2.expr is Double(3.14),
  )

  // Test 3: Top-level let with string: let s: String = "hello";
  let (top_let3, tok_view) = @parser.parse_top_let(tok_view)
  let checked_top_let3 = typecheck_ctx.check_top_let(top_let3)
  let knf_top_let3 = knf_ctx.top_let_to_knf(checked_top_let3)

  // Test 3: Check the structure
  assert_true(
    knf_top_let3.name is { id: "s", slot: 0 } &&
    knf_top_let3.ty is String &&
    knf_top_let3.expr is String("hello"),
  )

  // Test 4: Top-level let with computation: let sum = 10 + 20;
  let (top_let, tok_view) = @parser.parse_top_let(tok_view)
  let checked_top_let4 = typecheck_ctx.check_top_let(top_let)
  let _ = knf_ctx.top_let_to_knf(checked_top_let4)
  let (top_let, tok_view) = @parser.parse_top_let(tok_view)
  let checked_top_let4 = typecheck_ctx.check_top_let(top_let)
  let _ = knf_ctx.top_let_to_knf(checked_top_let4)
  let (top_let4, _) = @parser.parse_top_let(tok_view)
  let checked_top_let4 = typecheck_ctx.check_top_let(top_let4)
  let knf_top_let4 = knf_ctx.top_let_to_knf(checked_top_let4)
  assert_true(
    knf_top_let4.name is { id: "sum", slot: 0 } &&
    knf_top_let4.ty is Int &&
    knf_top_let4.expr is Binary(Add, l, r) &&
    l is { id: "a", .. } &&
    r is { id: "b", .. },
  )
}
/// ================================================================================
/// # ğŸš€ æ¬¢è¿æ¥åˆ° KNF å˜æ¢çš„ä¸–ç•Œï¼
///
/// ğŸ‰ **æ­å–œä½ å®Œæˆäº†ç±»å‹æ£€æŸ¥é˜¶æ®µçš„æ‰€æœ‰æŒ‘æˆ˜ï¼** ğŸ‰
///
/// ç°åœ¨ï¼Œæˆ‘ä»¬å°†è¿›å…¥ç¼–è¯‘å™¨æ„å»ºä¹‹æ—…çš„ç¬¬å››ä¸ªé‡è¦é˜¶æ®µï¼š**KNF å˜æ¢ (Kernel Normal Form Transformation)**ã€‚
/// è¿™æ˜¯è¿æ¥é«˜çº§è¯­è¨€å’Œåº•å±‚ä»£ç ç”Ÿæˆä¹‹é—´çš„å…³é”®æ¡¥æ¢ï¼
///
/// ## ğŸŒŸ ä»€ä¹ˆæ˜¯ä¸­é—´è¡¨ç¤º IRï¼Ÿ
///
/// åœ¨ç¼–è¯‘å™¨çš„ä¸–ç•Œä¸­ï¼Œ**ä¸­é—´è¡¨ç¤º (Intermediate Representation, IR)** æ˜¯ä¸€ä¸ªæå…¶é‡è¦çš„æ¦‚å¿µã€‚
/// æƒ³è±¡ä¸€ä¸‹ï¼Œç¼–è¯‘å™¨å°±åƒä¸€ä¸ªç¿»è¯‘å®˜ï¼Œéœ€è¦å°†äººç±»ç¼–å†™çš„é«˜çº§è¯­è¨€ä»£ç ç¿»è¯‘æˆæœºå™¨èƒ½å¤Ÿç†è§£çš„æŒ‡ä»¤ã€‚
/// ä½†æ˜¯ï¼Œè¿™ä¸ªç¿»è¯‘è¿‡ç¨‹å¾€å¾€ä¸æ˜¯ä¸€æ­¥åˆ°ä½çš„ï¼Œè€Œæ˜¯éœ€è¦ç»è¿‡å¤šä¸ªä¸­é—´æ­¥éª¤ã€‚
///
/// **IR å°±æ˜¯è¿™äº›ä¸­é—´æ­¥éª¤ä¸­çš„"é€šç”¨è¯­è¨€"**ï¼š
/// - å®ƒæ—¢ä¸åƒæºä»£ç é‚£æ ·å¤æ‚å’Œå¤šæ ·åŒ–
/// - ä¹Ÿä¸åƒæœºå™¨ç é‚£æ ·åº•å±‚å’Œç‰¹å®šäºç¡¬ä»¶
/// - è€Œæ˜¯å¤„äºä¸¤è€…ä¹‹é—´çš„ä¸€ä¸ª**æŠ½è±¡å±‚æ¬¡**ï¼Œæ—¢ä¿æŒäº†ç¨‹åºçš„æ ¸å¿ƒè¯­ä¹‰ï¼Œåˆç®€åŒ–äº†åç»­çš„å¤„ç†
///
/// ## ğŸ”„ ä»€ä¹ˆæ˜¯ ANFï¼Ÿ
///
/// **ANF (Administrative Normal Form)** æ˜¯ä¸€ç§é‡è¦çš„ä¸­é—´è¡¨ç¤ºå½¢å¼ã€‚
/// å®ƒçš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š**å°†æ‰€æœ‰çš„å¤æ‚è¡¨è¾¾å¼éƒ½åˆ†è§£æˆç®€å•çš„åŸå­æ“ä½œ**ã€‚
///
/// åœ¨ ANF ä¸­ï¼š
/// - æ¯ä¸ªè¡¨è¾¾å¼è¦ä¹ˆæ˜¯ä¸€ä¸ª**åŸå­å€¼**ï¼ˆå˜é‡ã€å­—é¢é‡ç­‰ï¼‰
/// - è¦ä¹ˆæ˜¯ä¸€ä¸ª**ç®€å•çš„å‡½æ•°è°ƒç”¨**ï¼Œå…¶å‚æ•°éƒ½æ˜¯åŸå­å€¼
/// - å¤æ‚çš„åµŒå¥—è¡¨è¾¾å¼ä¼šè¢«"æ‹‰å¹³"ï¼Œé€šè¿‡å¼•å…¥ä¸´æ—¶å˜é‡æ¥åˆ†è§£
///
/// ä¾‹å¦‚ï¼Œ`f(g(x), h(y))` ä¼šè¢«è½¬æ¢ä¸ºï¼š
/// ```
/// let temp1 = g(x)
/// let temp2 = h(y)
/// let result = f(temp1, temp2)
/// ```
///
/// ## âš¡ ä»€ä¹ˆæ˜¯ KNFï¼Ÿ
///
/// **KNF (Kernel Normal Form)** æ˜¯ ANF çš„ä¸€ä¸ªæ›´ä¸¥æ ¼çš„å˜ä½“ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬å½“å‰é˜¶æ®µè¦å®ç°çš„ä¸­é—´è¡¨ç¤ºã€‚
///
/// KNF åœ¨ ANF çš„åŸºç¡€ä¸Šè¿›ä¸€æ­¥ç®€åŒ–ï¼š
/// - **æ›´ä¸¥æ ¼çš„è¡¨è¾¾å¼ç»“æ„**ï¼šç¡®ä¿æ¯ä¸ªè¡¨è¾¾å¼éƒ½æ˜¯"åŸå­"çš„
/// - **ç»Ÿä¸€çš„æ§åˆ¶æµ**ï¼šæ‰€æœ‰çš„æ§åˆ¶æµéƒ½é€šè¿‡ç‰¹å®šçš„ç»“æ„æ¥è¡¨è¾¾
/// - **ç®€åŒ–çš„ç±»å‹ç³»ç»Ÿ**ï¼šç±»å‹ä¿¡æ¯è¢«è§„èŒƒåŒ–ï¼Œä¾¿äºåç»­å¤„ç†
///
/// KNF çš„ä¸»è¦ä¼˜åŠ¿ï¼š
/// - **ä¾¿äºä¼˜åŒ–**ï¼šç®€åŒ–çš„ç»“æ„è®©ç¼–è¯‘å™¨æ›´å®¹æ˜“è¿›è¡Œå„ç§ä¼˜åŒ–
/// - **ä¾¿äºä»£ç ç”Ÿæˆ**ï¼šæ¥è¿‘ç›®æ ‡æœºå™¨çš„æ‰§è¡Œæ¨¡å‹
/// - **ä¾¿äºåˆ†æ**ï¼šç¨‹åºçš„ç»“æ„æ›´åŠ æ¸…æ™°ï¼Œä¾¿äºé™æ€åˆ†æ
///
/// ## ğŸ¯ æˆ‘ä»¬ç°åœ¨å¤„äºä»€ä¹ˆä½ç½®ï¼Ÿ
///
/// è®©æˆ‘ä»¬å›é¡¾ä¸€ä¸‹ç¼–è¯‘å™¨çš„å®Œæ•´æµç¨‹ï¼š
///
/// ```
/// æºä»£ç  â†’ è¯æ³•åˆ†æ â†’ è¯­æ³•åˆ†æ â†’ ç±»å‹æ£€æŸ¥ â†’ **KNFå˜æ¢** â†’ LLVM(SSA) â†’ æœºå™¨ç 
/// ```
///
/// **æˆ‘ä»¬ç°åœ¨æ­£å¤„äº KNF å˜æ¢é˜¶æ®µï¼**
///
/// - âœ… **å·²å®Œæˆ**ï¼šè¯æ³•åˆ†æã€è¯­æ³•åˆ†æã€ç±»å‹æ£€æŸ¥
/// - ğŸ”„ **æ­£åœ¨è¿›è¡Œ**ï¼šKNF å˜æ¢
/// - â³ **å³å°†åˆ°æ¥**ï¼šLLVM ä»£ç ç”Ÿæˆï¼ˆSSA å½¢å¼ï¼‰
///
/// ## ğŸ”® æ¥ä¸‹æ¥ä¼šè¿›å…¥ LLVM (SSA)
///
/// å®Œæˆ KNF å˜æ¢åï¼Œæˆ‘ä»¬å°†è¿›å…¥ **LLVM ä»£ç ç”Ÿæˆé˜¶æ®µ**ã€‚
/// LLVM ä½¿ç”¨ **SSA (Static Single Assignment)** å½¢å¼ä½œä¸ºå…¶æ ¸å¿ƒä¸­é—´è¡¨ç¤ºï¼š
///
/// - **SSA ç‰¹ç‚¹**ï¼šæ¯ä¸ªå˜é‡åªè¢«èµ‹å€¼ä¸€æ¬¡ï¼Œé€šè¿‡ phi å‡½æ•°å¤„ç†æ§åˆ¶æµåˆå¹¶
/// - **LLVM ä¼˜åŠ¿**ï¼šæˆç†Ÿçš„ä¼˜åŒ–æ¡†æ¶ï¼Œæ”¯æŒå¤šç§ç›®æ ‡æ¶æ„
/// - **æˆ‘ä»¬çš„ç›®æ ‡**ï¼šå°† KNF å½¢å¼çš„ä»£ç è½¬æ¢ä¸º LLVM IRï¼Œæœ€ç»ˆç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶
///
/// ## ğŸ¯ ä½ çš„ä»»åŠ¡ï¼šå®ç°ç±»å‹å˜æ¢
///
/// åœ¨è¿™ä¸ªæµ‹è¯•æ–‡ä»¶ä¸­ï¼Œä½ éœ€è¦å®Œæˆ `type.mbt` æ–‡ä»¶ä¸­çš„ä¸¤ä¸ªå…³é”®å‡½æ•°ï¼š
///
/// ### 1. `typekind_to_knf` å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°è´Ÿè´£å°†ç±»å‹æ£€æŸ¥é˜¶æ®µçš„ `TypeKind` è½¬æ¢ä¸º KNF é˜¶æ®µçš„ `Type`ã€‚
/// ä½ éœ€è¦å¤„ç†å„ç§ç±»å‹ï¼š
/// - åŸºæœ¬ç±»å‹ï¼š`Unit`ã€`Int`ã€`Bool`ã€`Double`ã€`String`
/// - å¤åˆç±»å‹ï¼š`Array`ã€`Struct`ã€`Tuple`ã€`Function`
/// - é”™è¯¯å¤„ç†ï¼šå¯¹äºä¸æ”¯æŒçš„ç±»å‹ï¼ŒæŠ›å‡º `KnfTransformError`
///
/// ### 2. `type_to_knf` å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°æ˜¯ `typekind_to_knf` çš„åŒ…è£…å™¨ï¼Œå°†å®Œæ•´çš„ `@typecheck.Type` å¯¹è±¡è½¬æ¢ä¸º KNF çš„ `Type`ã€‚
///
/// ## ğŸ› ï¸ ä¸Šä¸‹æ–‡ç®¡ç†
///
/// ä¸typechecké˜¶æ®µä¸€æ ·ï¼Œæˆ‘ä»¬åŒæ ·éœ€è¦ä¸€ä¸ªContextç»“æ„ä½“æ¥ç®¡ç†ä¸Šä¸‹æ–‡ï¼Œä½†æœ‰æ‰€ä¸åŒçš„æ˜¯ï¼ŒTypechecké˜¶æ®µï¼Œ
/// æˆ‘ä»¬æŠŠæ¯ä¸€ä¸ªBlockçœ‹åšä¸€ä¸ªç‹¬ç«‹çš„ä½œç”¨åŸŸï¼Œè€Œåœ¨KNFé˜¶æ®µï¼Œæˆ‘ä»¬æŠŠæ•´ä¸ªå‡½æ•°ä½“çœ‹åšä¸€ä¸ªä½œç”¨åŸŸï¼Œ
///
/// `context.mbt` æ–‡ä»¶ä¸­å·²ç»å®šä¹‰å¥½äº† `Context` ç»“æ„ä½“ï¼Œä½ éœ€è¦ä½¿ç”¨å®ƒæ¥ç®¡ç†ç±»å‹å˜æ¢è¿‡ç¨‹ä¸­çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚
///
/// ## ğŸš€ å¼€å§‹ä½ çš„ KNF ä¹‹æ—…ï¼
///
/// ç±»å‹å˜æ¢æ˜¯ KNF å˜æ¢çš„åŸºç¡€ï¼Œåªæœ‰æ­£ç¡®åœ°å°†ç±»å‹ç³»ç»Ÿè½¬æ¢åˆ° KNF å½¢å¼ï¼Œ
/// æˆ‘ä»¬æ‰èƒ½ç»§ç»­è¿›è¡Œè¡¨è¾¾å¼å’Œè¯­å¥çš„å˜æ¢ã€‚
///
/// **å‡†å¤‡å¥½è¿æ¥è¿™ä¸ªæ¿€åŠ¨äººå¿ƒçš„æ–°é˜¶æ®µäº†å—ï¼Ÿè®©æˆ‘ä»¬å¼€å§‹å§ï¼**
/// ================================================================================

///|
test "Type Knf Transformation Test" {
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = Context::new()
  let code =
    #|Int Unit Bool Double String Array[Int]
    #|(Int, Double, Bool)
    #|(Int, Int) -> Bool
    #|(Array[Double]) -> String
  // Parse
  let tokens = @lexer.tokenize(code)
  let (t, tok_view) = @parser.parse_type(tokens)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Int)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Unit)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Bool)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Double)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is String)
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Array(Int))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Tuple([Int, Double, Bool]))
  let (t, tok_view) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Function([Int, Int], Bool))
  let (t, _) = @parser.parse_type(tok_view)
  let t = typecheck_ctx.check_parser_type(t)
  let t = knf_ctx.type_to_knf(t)
  assert_true(t is Function([Array(Double)], String))
}
/// ================================================================================
/// # ğŸ”„ While è¯­å¥çš„ KNF è½¬æ¢
///
/// ## ğŸ¯ ä»€ä¹ˆæ˜¯ While è¯­å¥ï¼Ÿ
///
/// While è¯­å¥æ˜¯ç¼–ç¨‹è¯­è¨€ä¸­çš„å¾ªç¯æ§åˆ¶ç»“æ„ï¼Œå®ƒå…è®¸ç¨‹åºé‡å¤æ‰§è¡Œä¸€æ®µä»£ç ï¼Œç›´åˆ°æŸä¸ªæ¡ä»¶ä¸å†æ»¡è¶³ã€‚
/// While è¯­å¥çš„åŸºæœ¬ç»“æ„æ˜¯ï¼š
/// while (condition) {
///   // å¾ªç¯ä½“
/// }
///
/// ## ğŸ” ç»“æ„å·®å¼‚åˆ†æ
///
/// åœ¨è¯­æ³•æ ‘ä¸­ï¼ŒWhile è¯­å¥çš„ç»“æ„ç›¸å¯¹ç®€å•ï¼š
/// - `cond`: æ¡ä»¶è¡¨è¾¾å¼
/// - `body`: å¾ªç¯ä½“ï¼ˆBlockExprï¼‰
///
/// ä½†åœ¨ KNF ä¸­ï¼ŒWhile è¯­å¥çš„ç»“æ„æ›´åŠ ç»Ÿä¸€ï¼š
/// - `KnfStmt::While(cond_block, body_block)`
/// - æ¡ä»¶è¢«åŒ…è£…åœ¨ä¸€ä¸ª `KnfBlock` ä¸­
/// - å¾ªç¯ä½“ä¹Ÿè¢«åŒ…è£…åœ¨ä¸€ä¸ª `KnfBlock` ä¸­
///
/// ## ğŸ› ï¸ å®ç°æ€è·¯
///
/// å®ç° `while_stmt_to_knf` å‡½æ•°éœ€è¦ä¸‰ä¸ªä¸»è¦æ­¥éª¤ï¼š
///
/// ### 1. æ¡ä»¶è½¬æ¢
/// - ä½¿ç”¨ `expr_to_knf` è½¬æ¢æ¡ä»¶è¡¨è¾¾å¼
/// - å°†æ¡ä»¶è¯­å¥åŒ…è£…ä¸º `ExprStmt`
/// - åˆ›å»ºæ¡ä»¶å— `KnfBlock`
///
/// ### 2. å¾ªç¯ä½“è½¬æ¢
/// - ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢å¾ªç¯ä½“
/// - ç›´æ¥å¾—åˆ° `KnfBlock`
///
/// ### 3. æ„é€  While è¯­å¥
/// - åˆ›å»º `KnfStmt::While(cond_block, body_block)`
/// - è¿”å›åŒ…å«å•ä¸ª While è¯­å¥çš„æ•°ç»„
///
/// ## ğŸ”§ å…³é”®å®ç°ç»†èŠ‚
///
/// ### æ¡ä»¶å—å¤„ç†
/// æ¡ä»¶è¡¨è¾¾å¼å¯èƒ½åŒ…å«å¤æ‚çš„å­è¡¨è¾¾å¼ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸º KNFï¼š
/// while (i < 10) { ... }
/// è½¬æ¢ä¸ºï¼š
/// let tmp = 10;
/// while (i < tmp) { ... }
///
/// ### å¾ªç¯ä½“å¤„ç†
/// å¾ªç¯ä½“æ˜¯ä¸€ä¸ª `BlockExpr`ï¼Œç›´æ¥ä½¿ç”¨ `block_expr_to_knf` è½¬æ¢ï¼š
/// {
///   sum = sum + i;
///   i = i + 1;
/// }
/// è½¬æ¢ä¸ºï¼š
/// {
///   sum = sum + i;
///   let tmp = 1;
///   i = i + tmp;
/// }
///
/// ### ç»Ÿä¸€ç»“æ„
/// KNF ä¸­çš„ While è¯­å¥ç»“æ„ç»Ÿä¸€ä¸ºï¼š
/// While(cond_block, body_block)
/// å…¶ä¸­ï¼š
/// - `cond_block`: åŒ…å«æ¡ä»¶è®¡ç®—å’Œæ¡ä»¶è¡¨è¾¾å¼çš„è¯­å¥å—
/// - `body_block`: åŒ…å«å¾ªç¯ä½“è¯­å¥çš„è¯­å¥å—
///
/// ## ğŸ“ æµ‹è¯•ç”¨ä¾‹è§£æ
///
/// ### æµ‹è¯•ç”¨ä¾‹ 1ï¼šç®€å•å¾ªç¯
/// while (i < 10) {
///   sum = sum + i;
///   i = i + 1;
/// }
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. æ¡ä»¶ `i < 10` è½¬æ¢ä¸º `let tmp = 10; i < tmp`
/// 2. å¾ªç¯ä½“è½¬æ¢ä¸ºåŒ…å«èµ‹å€¼å’Œå¢é‡æ“ä½œçš„è¯­å¥å—
/// 3. æ„é€  `While(cond_block, body_block)`
///
/// ### æµ‹è¯•ç”¨ä¾‹ 2ï¼šå¸¦å‡½æ•°è°ƒç”¨çš„å¾ªç¯
/// 
/// ```
/// while (x > 0) {
///   print_int(x);
///   x = x - 1;
/// }
/// ```
/// è½¬æ¢è¿‡ç¨‹ï¼š
/// 1. æ¡ä»¶ `x > 0` è½¬æ¢ä¸º `let tmp = 0; x > tmp`
/// 2. å¾ªç¯ä½“åŒ…å«å‡½æ•°è°ƒç”¨å’Œé€’å‡æ“ä½œ
/// 3. æ„é€  `While(cond_block, body_block)`
///
/// ## ğŸ’¡ è®¾è®¡æ€æƒ³
///
/// ### ç»Ÿä¸€ç»“æ„
/// å°†æ¡ä»¶è¡¨è¾¾å¼åŒ…è£…åœ¨ `KnfBlock` ä¸­ï¼Œä½¿å¾— While è¯­å¥çš„ç»“æ„æ›´åŠ ç»Ÿä¸€å’Œä¸€è‡´ã€‚
///
/// ### æ¡ä»¶è®¡ç®—
/// æ¡ä»¶è¡¨è¾¾å¼ä¸­çš„å¤æ‚è®¡ç®—è¢«æå–ä¸ºç‹¬ç«‹çš„è¯­å¥ï¼Œç¡®ä¿æ¡ä»¶åˆ¤æ–­çš„åŸå­æ€§ã€‚
///
/// ### å¾ªç¯ä½“å¤„ç†
/// å¾ªç¯ä½“ä½œä¸º `BlockExpr` ç›´æ¥è½¬æ¢ï¼Œä¿æŒåŸæœ‰çš„è¯­å¥ç»“æ„ã€‚
///
/// ### ç®€åŒ–è¡¨ç¤º
/// åœ¨ KNF ä¸­ç®€åŒ–å¾ªç¯æ§åˆ¶æµçš„è¡¨ç¤ºï¼Œä¸ºåç»­çš„ä¼˜åŒ–å’Œä»£ç ç”Ÿæˆåšå‡†å¤‡ã€‚
///
/// ## ğŸš€ å®ç°æŒ‘æˆ˜
///
/// ### æ¡ä»¶è¡¨è¾¾å¼å¤æ‚æ€§
/// æ¡ä»¶è¡¨è¾¾å¼å¯èƒ½åŒ…å«å‡½æ•°è°ƒç”¨ã€å¤æ‚è¿ç®—ç­‰ï¼Œéœ€è¦æ­£ç¡®è½¬æ¢ä¸º KNF å½¢å¼ã€‚
///
/// ### å¾ªç¯ä½“è¯­å¥
/// å¾ªç¯ä½“ä¸­çš„è¯­å¥éœ€è¦æ­£ç¡®è½¬æ¢ï¼ŒåŒ…æ‹¬èµ‹å€¼ã€å‡½æ•°è°ƒç”¨ç­‰ã€‚
///
/// ### ä¸´æ—¶å˜é‡ç®¡ç†
/// æ¡ä»¶è¡¨è¾¾å¼ä¸­çš„ä¸´æ—¶å˜é‡éœ€è¦æ­£ç¡®ç®¡ç†ï¼Œé¿å…å‘½åå†²çªã€‚
///
/// ## ğŸ¯ å®ç°ç›®æ ‡
///
/// å®Œæˆ `while_stmt.mbt` ä¸­çš„ `while_stmt_to_knf` å‡½æ•°ï¼Œå®ç° While è¯­å¥çš„ KNF è½¬æ¢ã€‚
/// å‡½æ•°åº”è¯¥ï¼š
/// 1. æ­£ç¡®è½¬æ¢æ¡ä»¶è¡¨è¾¾å¼ä¸ºæ¡ä»¶å—
/// 2. æ­£ç¡®è½¬æ¢å¾ªç¯ä½“ä¸ºè¯­å¥å—
/// 3. æ„é€ ç»Ÿä¸€çš„ While è¯­å¥ç»“æ„
/// 4. å¤„ç†å¤æ‚çš„æ¡ä»¶è¡¨è¾¾å¼å’Œå¾ªç¯ä½“è¯­å¥
///
/// ç°åœ¨è®©æˆ‘ä»¬å¼€å§‹å®ç° While è¯­å¥çš„è½¬æ¢å§ï¼ğŸš€
///
/// ================================================================================

///|
test "While Stmt Knf Transformation Test" {
  // Prelude Parts
  let typecheck_ctx = @typecheck.Context::new()
  let knf_ctx = @knf.Context::new()

  // Setup type environment for testing
  typecheck_ctx.type_env.set("i", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("sum", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("x", { kind: Int, mutable: true })
  typecheck_ctx.type_env.set("print_int", {
    kind: Function([Int], Unit),
    mutable: false,
  })

  // Setup knf context
  let _ = knf_ctx.add_new_name("i", Int)
  let _ = knf_ctx.add_new_name("sum", Int)
  let _ = knf_ctx.add_new_name("x", Int)
  knf_ctx.globals.set("print_int", Function([Int], Unit))

  // Test 1: Simple while loop: while (i < 10) { sum = sum + i; i = i + 1; }
  let code1 =
    #|while (i < 10) {
    #|  sum = sum + i;
    #|  i = i + 1;
    #|}
  let tokens1 = @lexer.tokenize(code1)
  let (while_stmt1, _) = @parser.parse_while_stmt(tokens1)
  let checked_while_stmt1 = typecheck_ctx.check_while_stmt(while_stmt1)
  let knf_while_stmts1 = knf_ctx.while_stmt_to_knf(checked_while_stmt1)

  // Test 1: Check that we get a While statement
  assert_true(knf_while_stmts1.length() is 1)
  assert_true(knf_while_stmts1[0] is While(_, _))
  guard knf_while_stmts1[0] is While(cond_block, body_block)

  // Test 1: Check condition block (should have let for 10 and the condition expression)
  // Condition block should have: let tmp = 10; and i < tmp;
  assert_true(cond_block.stmts.length() is 2)
  assert_true(
    cond_block.stmts[0] is Let(tmp_name, Int, Int(10)) &&
    tmp_name is { id: "tmp", slot: 0 },
  )
  assert_true(
    cond_block.stmts[1] is ExprStmt(Binary(LT, i_name, tmp_cond)) &&
    i_name is { id: "i", .. } &&
    tmp_cond is { id: "tmp", slot: 0 },
  )

  // Body block should have:
  // 1. sum = sum + i; (no expansion needed, operands are identifiers)
  // 2. let tmp$1 : Int = 1; (extract literal)
  // 3. i = i + tmp$1; (assignment)
  assert_true(body_block.stmts.length() is 3)
  assert_true(
    body_block.stmts[0] is Assign(sum_name, Binary(Add, sum_name2, i_name2)) &&
    sum_name is { id: "sum", .. } &&
    sum_name2 is { id: "sum", .. } &&
    i_name2 is { id: "i", .. },
  )
  assert_true(
    body_block.stmts[1] is Let(tmp_lit, Int, Int(1)) &&
    tmp_lit is { id: "tmp", slot: 1 },
  )
  assert_true(
    body_block.stmts[2] is Assign(i_name3, Binary(Add, i_name4, tmp_add)) &&
    i_name3 is { id: "i", .. } &&
    i_name4 is { id: "i", .. } &&
    tmp_add is { id: "tmp", slot: 1 },
  )

  // Test 2: While with function call: while (x > 0) { print_int(x); x = x - 1; }
  let code2 =
    #|while (x > 0) {
    #|  print_int(x);
    #|  x = x - 1;
    #|}
  let tokens2 = @lexer.tokenize(code2)
  let (while_stmt2, _) = @parser.parse_while_stmt(tokens2)
  let checked_while_stmt2 = typecheck_ctx.check_while_stmt(while_stmt2)
  let knf_while_stmts2 = knf_ctx.while_stmt_to_knf(checked_while_stmt2)
  assert_true(knf_while_stmts2.length() is 1)
  guard knf_while_stmts2[0] is While(cond_block, body_block)

  // Test 2: Check structure
  // Condition block: let tmp = 0; x > tmp;
  assert_true(cond_block.stmts.length() is 2)
  assert_true(
    cond_block.stmts[0] is Let(_, Int, Int(0)) &&
    cond_block.stmts[1] is ExprStmt(Binary(GT, _, _)),
  )

  // Body block: print_int(x); x = x - 1;
  // Similar to test 1: print_int(x); let tmp = 1; x = x - tmp;
  assert_true(body_block.stmts.length() is 3)
  assert_true(body_block.stmts[0] is ExprStmt(Call(_, _)))
  assert_true(body_block.stmts[1] is Let(_, Int, Int(1)))
  assert_true(body_block.stmts[2] is Assign(_, Binary(Sub, _, _)))
}
